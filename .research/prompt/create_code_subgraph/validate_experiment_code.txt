
LLM Name: o3-2025-04-16
Input:
You are an AI code reviewer validating production-ready experiment code for research papers.

Analyze the provided experiment code and determine if it meets all requirements for immediate execution in research experiments.

# Instructions

## Core Validation Criteria
Check if the generated experiment code meets ALL of the following requirements:

1. **Complete Implementation**:
   - Every component is fully functional, production-ready, publication-worthy code
   - No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
   - All functions and classes are completely implemented
   - No truncated code sections or incomplete implementations

2. **Hydra Integration**:
   - Uses Hydra to manage all experiment configurations from `config/run/*.yaml` files
   - All parameters are loaded from run configs dynamically
   - Proper configuration structure with run_id, method, model, dataset, training, and optuna sections
   - CLI interface matches:
     * Training: `uv run python -u -m src.main run={run_id} results_dir={path}`
     * Evaluation: `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'` (independent execution)
   - Supports trial_mode=true flag for lightweight validation runs (automatically disables WandB)

3. **Complete Data Pipeline**:
   - Full data loading and preprocessing implementation
   - Dataset-specific preprocessing is properly implemented
   - No placeholder dataset loading code
   - Proper error handling for data operations
   - Uses `.cache/` as the cache directory for all datasets and models

4. **Model Implementation**:
   - Complete model architectures for all methods (proposed and comparative methods)
   - No placeholders (TODO, PLACEHOLDER, pass, or incomplete implementations)
   - When External Resources specify HuggingFace models: properly use and customize them (acceptable to wrap AutoModel, add adapters, etc.)
   - When no external models specified: implement architectures from scratch using PyTorch primitives
   - Model-specific configurations correctly applied
   - Proper PyTorch usage throughout

5. **File Structure Compliance**:
   - Contains EXACTLY these required files (and NO other files):
     * `src/train.py`
     * `src/evaluate.py`
     * `src/preprocess.py`
     * `src/model.py`
     * `src/main.py`
     * `pyproject.toml`
     * `config/config.yaml`
   - NO additional files (e.g., NO `src/__init__.py`, NO `setup.py`, NO other Python files)
   - No missing files from the structure
   - All functionality contained within specified files

6. **WandB Integration**:
   - train.py initializes WandB and logs ALL metrics comprehensively:
     * Use `wandb.log()` at each training step/batch/epoch with ALL relevant time-series metrics
     * Log as frequently as possible (per-batch or per-epoch) to capture complete training dynamics
     * Use `wandb.summary["key"] = value` to save final/best metrics (best_val_acc, final_test_acc, best_epoch, etc.)
   - trial_mode automatically disables WandB (sets wandb.mode=disabled)
   - NO results.json or stdout JSON dumps in train.py
   - config/config.yaml contains mandatory WandB settings (entity/project)

7. **Configuration Files**:
   - The generated code properly references config files via Hydra
   - NOTE: config/run/{run_id}.yaml files are provided separately (not in ExperimentCode)
   - All run configurations match the experiment_runs provided
   - Optuna search spaces are properly defined if applicable

8. **Evaluation Script Independence**:
   - evaluate.py is executed independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
   - Accepts `run_ids` parameter as JSON string list (parse with `json.loads(args.run_ids)`)
   - main.py DOES NOT call evaluate.py
   - evaluate.py retrieves comprehensive data from WandB API:
     * Use `wandb.Api()` to get run data: `run = api.run(f"{entity}/{project}/{run_id}")`
     * Retrieve: `history = run.history()`, `summary = run.summary._json_dict`, `config = dict(run.config)`
   - **STEP 1: Per-Run Processing** (for each run_id):
     * Export comprehensive run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
     * Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
     * Each run should have its own subdirectory with its metrics and figures
   - **STEP 2: Aggregated Analysis** (after processing all runs):
     * Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
     * Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
     * Generate comparison figures to: `{results_dir}/comparison/`
     * Cross-run comparison charts (bar charts, box plots)
     * Performance metrics tables
     * Statistical significance tests
   - Proper figure quality: legends, annotations, tight_layout
   - Follows GLOBALLY UNIQUE naming convention to prevent collisions:
     * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
     * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
   - train.py and main.py generate NO figures
   - evaluate.py cannot run in trial_mode (no WandB data available when WandB disabled)

9. **Trial Mode Implementation**:
   - trial_mode=true flag properly reduces computational load
   - Training: epochs=1, batches limited to 1-2, Optuna disabled (n_trials=0), small evaluation subset
   - WandB automatically disabled in trial_mode (wandb.mode=disabled)
   - Purpose: Fast validation that code runs without errors

## Output Format
Respond with a JSON object containing:
- `is_code_ready`: boolean - true if ALL criteria are met, false otherwise
- `code_issue`: string - specific issues found if any criteria are not met, focusing on what needs to be fixed

# Current Research Method
{
    "Open Problems": "In BOIL the trade-off between expected utility (EI) and training cost uses a plain LinearRegression model that outputs only the cost mean.  • Learning curves in practice exhibit highly non-linear, heteroscedastic cost patterns (e.g. GPU time depends on batch-size, network width, data-set size, etc.).  • Ignoring cost uncertainty can mis-rank candidate points and waste optimisation budget.  A minimal change that adds uncertainty estimates to the cost model can address this limitation without touching BOIL’s learning-curve GP or augmentation machinery.",
    "Methods": "We keep BOIL intact but replace its cost proxy with a BayesianRidge regressor and modify the acquisition so that the denominator is the optimistic cost mean augmented by a multiple of its predictive standard deviation.  Concretely:  1. Fit sklearn.linear_model.BayesianRidge on concatenated (x,t) → observed_cost.  2. At a candidate z=[x,t] obtain posterior mean μ_c and std σ_c.  3. New cost-aware acquisition:  A(z)=log(EI(z))−log( μ_c + β·σ_c + ε )  (ε=1e−6).  Setting β∈[0,2] interpolates between risk-neutral (β=0, original BOIL) and risk-averse (β>0).  Motivation: penalise points whose cost is both high and uncertain, leading to more reliable wall-clock savings while changing only 5 lines of code.",
    "Experimental Setup": "Data sets: CIFAR-10 CNN (same as BOIL repo) and CartPole-v0 DQN.  Budget: 50 BO iterations, 5 random seeds.  Methods compared: (i) Original BOIL, (ii) BOIL-UC (β=1).  Metrics:  • Wall-clock minutes until the incumbent reaches 90% of best-known test accuracy / return.  • Area-under-curve of best-so-far metric vs time.  Hardware and other hyper-parameters identical to BOIL paper to ensure fair comparison.",
    "Experimental Code": "# --- only the changed parts ---\nfrom sklearn.linear_model import BayesianRidge\n\nclass BOIL_UC(BOIL):\n    def __init__(self,*args, beta_uncert=1.0, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.beta_uncert = beta_uncert\n        # replace linear cost model\n        self.cost_model = BayesianRidge()\n\n    # override utility-cost computation\n    def utility_cost_evaluation(self, z, acq_func, isDebug=False):\n        def _single(z):\n            util = acq_func.acq_kind(z, gp=self.gp)               # EI part (unchanged)\n            mu_c, std_c = self.cost_model.predict(z.reshape(1,-1), return_std=True)\n            adj_cost = max(0.0, mu_c) + self.beta_uncert*std_c + 1e-6\n            return np.log(util) - np.log(adj_cost)\n        if z.ndim==1:\n            return -_single(z)\n        return -np.asarray([_single(p) for p in z])\n\n    # call after every true evaluation\n    def update_cost_model(self):\n        Z = np.hstack((self.X, self.T))\n        self.cost_model.fit(Z, self.Y_cost)\n\n    # ensure model update before acquisition optimisation\n    def suggest_nextpoint(self):\n        self.update_cost_model()\n        return super().suggest_nextpoint()\n",
    "Expected Result": "Across both benchmarks BOIL-UC should reach the target performance about 10-20 % faster in wall-clock time.  The AUC metric is expected to be higher (lower is better) for BOIL-UC in ≥4 of 5 seeds, indicating more consistent cost-aware choices.  When β is set to 0 we exactly reproduce original BOIL numbers, confirming minimal overhead.",
    "Expected Conclusion": "Adding a Bayesian cost model with uncertainty weighting is a tiny change (replace LinearRegression, adjust 5 code lines) yet yields tangible speed-ups and stabler optimisation.  The improvement arises because the acquisition now avoids hyper-parameters whose training cost is both high and uncertain, focusing exploration on cheaper, safer regions.  This demonstrates that even in sophisticated BO frameworks, incorporating predictive uncertainty on auxiliary objectives can provide outsized practical gains with negligible implementation effort."
}

# Experimental Design
- Strategy: We compare the original BOIL (Bayesian Optimisation for Learning-curves) against BOIL-UC, our drop-in replacement that equips BOIL with a BayesianRidge cost model and an uncertainty-aware acquisition denominator.  Both algorithms optimise hyper-parameters for training a fixed ResNet-18 on CIFAR-10.  In each BO iteration the candidate (network width, batch-size, learning-rate, etc.) is selected, its single training run is launched, resulting learning-curve observations update BOIL’s GP (utility) and the BayesianRidge (cost).  The acquisition used by BOIL-UC is A(z)=log(EI(z))−log(μ_c+β·σ_c+1e-6).  Experiments run for 50 BO iterations under five random seeds on one A100 GPU.  Wall-clock time until the best validation accuracy reaches 90 % of the global optimum and the time-AUC of best-so-far accuracy are recorded.  The whole workflow is automated via the existing BOIL code-base; only ~15 lines are added to swap the cost model, compute μ_c,σ_c and update β.  Hyper-parameter β is tuned by grid search and the best value is used for the final comparison.
- Proposed Method: BOIL-UC (Bayesian Optimistic Cost).  Objective: accelerate wall-clock convergence of Bayesian hyper-parameter optimisation by accounting for both mean and uncertainty of training cost.
Components:
1. Utility model (unchanged): Gaussian Process on learning-curve features to yield Expected Improvement EI(z).
2. Cost model (new): sklearn.linear_model.BayesianRidge trained on concatenated design-time features (x,t) → observed GPU minutes.  Gives posterior mean μ_c and std σ_c.
3. Acquisition: A(z)=log(EI(z))−log(μ_c+βσ_c+ε) where ε=1e-6.  β∈[0,2] trades risk-neutral for risk-averse behaviour.
4. Algorithmic steps per BO iteration:
   a. Fit/update GP and BayesianRidge with all past data.
   b. Optimise A(z) with multistart L-BFGS to choose next configuration.
   c. Train the candidate model until time t, record validation accuracy, training cost.
   d. Append observations and repeat.
Theoretically, incorporating σ_c makes A(z) proportional to an upper-confidence bound on 1/cost, reducing probability of selecting expensive or uncertain runs.  Implementation requires replacing LinearRegression with BayesianRidge, calling predict(...,return_std=True) and adding βσ_c in the denominator.
- Evaluation Metrics: ['Time-to-Target (minutes)', 'AUC_BestSoFar']

# Experiment Runs

- Run ID: proposed-ResNet-18-11.7-M--CIFAR-10
  Method: proposed
  Model: ResNet-18 (11.7 M)
  Dataset: CIFAR-10
  
  Config Content:
  ```yaml
  run_id: proposed-ResNet-18-11.7-M--CIFAR-10
method: proposed
model:
  name: ResNet-18
  num_layers: 18
  width: 64
  pretrained: false
  num_parameters: 11.7M
dataset:
  name: CIFAR-10
  data_dir: ./data/cifar10
  input_size: 32
  num_classes: 10
  augmentation:
    random_crop:
      size: 32
      padding: 4
    random_horizontal_flip: 0.5
    normalization:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2470, 0.2435, 0.2616]
  train_val_split: [0.9, 0.1]
training:
  optimizer: sgd
  learning_rate: 0.1
  momentum: 0.9
  weight_decay: 5e-4
  scheduler: cosine
  batch_size: 256
  epochs: 200
  num_workers: 8
algorithm:
  name: BOIL-UC
  bo_iterations: 50
  random_seeds: [0, 1, 2, 3, 4]
  beta_uncert: 1.0
  acquisition: "log(EI) - log(mu_c + beta_uncert * sigma_c + 1e-6)"
cost_model:
  type: BayesianRidge
  alpha_1: 1e-6
  lambda_1: 1e-6
optuna:
  n_trials: 30
  direction: minimize
  search_space:
    beta_uncert:
      type: categorical
      choices: [0, 0.5, 1.0, 2.0]
    alpha_1:
      type: loguniform
      low: 1e-7
      high: 1e-5
    lambda_1:
      type: loguniform
      low: 1e-7
      high: 1e-5

  ```
  

- Run ID: comparative-1-ResNet-18-11.7-M--CIFAR-10
  Method: comparative-1
  Model: ResNet-18 (11.7 M)
  Dataset: CIFAR-10
  
  Config Content:
  ```yaml
  run_id: comparative-1-ResNet-18-11.7-M--CIFAR-10
method: comparative-1
model:
  name: ResNet-18
  num_layers: 18
  width: 64
  pretrained: false
  num_parameters: 11.7M
dataset:
  name: CIFAR-10
  data_dir: ./data/cifar10
  input_size: 32
  num_classes: 10
  augmentation:
    random_crop:
      size: 32
      padding: 4
    random_horizontal_flip: 0.5
    normalization:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2470, 0.2435, 0.2616]
  train_val_split: [0.9, 0.1]
training:
  optimizer: sgd
  learning_rate: 0.1
  momentum: 0.9
  weight_decay: 5e-4
  scheduler: cosine
  batch_size: 256
  epochs: 200
  num_workers: 8
algorithm:
  name: BOIL
  bo_iterations: 50
  random_seeds: [0, 1, 2, 3, 4]
cost_model:
  type: LinearRegression
optuna:
  n_trials: 1
  search_space: {}

  ```
  


# Generated Experiment Code (To be validated)
{"config_yaml": "wandb:\n  entity: gengaru617-personal\n  project: 251021-test\n  mode: online\n\n# Trial mode flag; can be overridden from CLI\ntrial_mode: false\n\n# Default results directory (override from CLI)\nresults_dir: ./results\n\nseed: 42\n\n# -----------------------------------------------------------------------------\n# Mandatory structure for run-level overrides. Values here act as safe defaults.\n# -----------------------------------------------------------------------------\nrun:\n  run_id: default-run\n\nmethod: baseline\n\nmodel:\n  name: ResNet-18\n  pretrained: false\n\ndataset:\n  name: CIFAR-10\n  num_classes: 10\n  train_val_split: [0.9, 0.1]\n  augmentation:\n    random_crop:\n      size: 32\n      padding: 4\n    random_horizontal_flip: 0.5\n    normalization:\n      mean: [0.4914, 0.4822, 0.4465]\n      std:  [0.2470, 0.2435, 0.2616]\n\ntraining:\n  optimizer: sgd\n  learning_rate: 0.1\n  momentum: 0.9\n  weight_decay: 5e-4\n  scheduler: cosine\n  batch_size: 256\n  epochs: 20\n  num_workers: 4\n\nalgorithm:\n  name: none\n  bo_iterations: 0\n  random_seeds: [0]\n  beta_uncert: 1.0\n  init_random: 5\n  random_candidates: 64\n\ncost_model:\n  type: LinearRegression\n\noptuna:\n  n_trials: 0\n  direction: minimize\n  search_space: {}\n", "evaluate_py": "import argparse\nimport json\nfrom pathlib import Path\nfrom typing import List, Dict, Any\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import ttest_ind\nimport wandb\nfrom omegaconf import OmegaConf\n\nplt.rcParams.update({\"pdf.fonttype\": 42, \"ps.fonttype\": 42})  # publication-ready\n\n\ndef _save_json(obj: Any, path: Path) -\u003e None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\") as f:\n        json.dump(obj, f, indent=2)\n\n\ndef _generate_learning_curve(history_df: pd.DataFrame, run_id: str, out_dir: Path) -\u003e Path:\n    plt.figure(figsize=(8, 5))\n    epochs = history_df.get(\"epoch\", pd.Series(range(len(history_df))))\n    if \"val_acc\" in history_df.columns:\n        plt.plot(epochs, history_df[\"val_acc\"], label=\"Val Acc\")\n    if \"train_acc\" in history_df.columns:\n        plt.plot(epochs, history_df[\"train_acc\"], label=\"Train Acc\")\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(f\"Learning Curve \u2013 {run_id}\")\n    plt.legend()\n    plt.tight_layout()\n    fig_path = out_dir / f\"{run_id}_learning_curve.pdf\"\n    plt.savefig(fig_path)\n    plt.close()\n    return fig_path\n\n\ndef _generate_confusion_matrix(cm: List[List[int]], run_id: str, out_dir: Path) -\u003e Path:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(np.array(cm), annot=True, fmt=\"d\", cmap=\"Blues\")\n    plt.title(f\"Confusion Matrix \u2013 {run_id}\")\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"True\")\n    plt.tight_layout()\n    fig_path = out_dir / f\"{run_id}_confusion_matrix.pdf\"\n    plt.savefig(fig_path)\n    plt.close()\n    return fig_path\n\n\ndef main() -\u003e None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str, help=\"Directory containing experiment metadata\")\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON string list of run IDs to evaluate\")\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir)\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    # -------------------- Load global config (entity / project) --------------------\n    cfg_path = results_dir / \"config.yaml\"\n    if not cfg_path.exists():\n        raise FileNotFoundError(f\"Expected config.yaml at {cfg_path}\")\n    cfg = OmegaConf.load(cfg_path)\n    entity, project = cfg.wandb.entity, cfg.wandb.project\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict[str, Any]] = {}\n    generated_files: List[Path] = []\n\n    # -------------------- per-run processing --------------------\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        history_df = run.history(keys=None)  # all metrics\n        summary = run.summary._json_dict\n        config = dict(run.config)\n\n        run_dir = results_dir / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n\n        metrics_path = run_dir / \"metrics.json\"\n        _save_json(history_df.to_dict(orient=\"list\"), metrics_path)\n        generated_files.append(metrics_path)\n\n        lc_path = _generate_learning_curve(history_df, rid, run_dir)\n        generated_files.append(lc_path)\n\n        if \"confusion_matrix\" in summary and summary[\"confusion_matrix\"] is not None:\n            cm_path = _generate_confusion_matrix(summary[\"confusion_matrix\"], rid, run_dir)\n            generated_files.append(cm_path)\n\n        aggregated[rid] = {\n            \"best_val_acc\": summary.get(\"best_val_acc\", summary.get(\"optuna_best_val_acc\")),\n            \"training_time\": summary.get(\"training_time\", 0.0),\n            \"method\": config.get(\"method\"),\n        }\n\n    # -------------------- aggregated analysis --------------------\n    cmp_dir = results_dir / \"comparison\"\n    cmp_dir.mkdir(parents=True, exist_ok=True)\n\n    aggregated_path = cmp_dir / \"aggregated_metrics.json\"\n    _save_json(aggregated, aggregated_path)\n    generated_files.append(aggregated_path)\n\n    df = pd.DataFrame.from_dict(aggregated, orient=\"index\")\n\n    # group by method for statistical comparison\n    methods = df[\"method\"].unique()\n    improvement_summary: Dict[str, Any] = {}\n    baseline_method = None\n    for m in methods:\n        if \"baseline\" in str(m).lower() or \"comparative\" in str(m).lower():\n            baseline_method = m\n            break\n    if baseline_method is not None:\n        baseline_vals = df[df[\"method\"] == baseline_method][\"best_val_acc\"].values.astype(float)\n        for m in methods:\n            if m == baseline_method:\n                continue\n            other_vals = df[df[\"method\"] == m][\"best_val_acc\"].values.astype(float)\n            if other_vals.size == 0:\n                continue\n            improvement = (other_vals.mean() - baseline_vals.mean()) / baseline_vals.mean()\n            stat, p_val = ttest_ind(other_vals, baseline_vals, equal_var=False)\n            improvement_summary[m] = {\n                \"improvement_vs_baseline\": improvement,\n                \"p_value\": p_val,\n            }\n    improvement_path = cmp_dir / \"derived_metrics.json\"\n    _save_json(improvement_summary, improvement_path)\n    generated_files.append(improvement_path)\n\n    # -------------------- figures --------------------\n    plt.figure(figsize=(10, 5))\n    sns.barplot(x=df.index, y=\"best_val_acc\", hue=\"method\", data=df)\n    for idx, val in enumerate(df[\"best_val_acc\"]):\n        plt.text(idx, val + 0.001, f\"{val:.3f}\", ha=\"center\", va=\"bottom\", fontsize=8)\n    plt.ylabel(\"Best Val Accuracy\")\n    plt.title(\"Best Validation Accuracy per Run\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    bar_path = cmp_dir / \"comparison_best_val_acc_bar_chart.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    generated_files.append(bar_path)\n\n    # print all generated file paths -----------------------------------------------\n    for p in generated_files:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "import subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nfrom omegaconf import DictConfig, OmegaConf\nimport hydra\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg: DictConfig) -\u003e None:\n    # Ensure results directory exists --------------------------------------------------\n    results_dir = Path(cfg.results_dir)\n    results_dir.mkdir(parents=True, exist_ok=True)\n    OmegaConf.save(config=cfg, f=str(results_dir / \"config.yaml\"))\n\n    overrides: List[str] = [f\"run={cfg.run.run_id}\", f\"results_dir={cfg.results_dir}\"]\n\n    if cfg.get(\"trial_mode\", False):\n        overrides.extend([\n            \"trial_mode=true\",\n            \"wandb.mode=disabled\",\n            \"training.epochs=1\",\n            \"algorithm.bo_iterations=1\",\n            \"optuna.n_trials=0\",\n        ])\n\n    # Let the child Hydra write its outputs inside the run-specific folder\n    overrides.append(f\"hydra.run.dir={cfg.results_dir}/{cfg.run.run_id}/hydra\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + overrides\n    print(\"Executing:\", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "from typing import Dict\n\nimport torch.nn as nn\nfrom torchvision import models\nfrom omegaconf import DictConfig\n\n\ndef build_model(cfg: DictConfig) -\u003e nn.Module:\n    name = str(cfg.model.name).lower()\n    num_classes = int(cfg.dataset.num_classes)\n    pretrained = bool(cfg.model.get(\"pretrained\", False))\n\n    if name in (\"resnet-18\", \"resnet18\"):\n        weights = models.ResNet18_Weights.DEFAULT if pretrained else None\n        model = models.resnet18(weights=weights)\n        model.fc = nn.Linear(model.fc.in_features, num_classes)\n    else:\n        raise ValueError(f\"Unsupported model architecture: {cfg.model.name}\")\n    return model\n", "preprocess_py": "from pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import datasets, transforms\nfrom omegaconf import DictConfig\n\nCACHE_DIR = Path(\".cache/datasets\")\nCACHE_DIR.mkdir(parents=True, exist_ok=True)\n\n\ndef _build_transforms(aug_cfg: DictConfig, is_train: bool):\n    t_list = []\n    if is_train and aug_cfg is not None:\n        if \"random_crop\" in aug_cfg:\n            rc = aug_cfg.random_crop\n            t_list.append(transforms.RandomCrop(rc.size, padding=rc.padding))\n        if \"random_horizontal_flip\" in aug_cfg:\n            prob = aug_cfg.random_horizontal_flip\n            t_list.append(transforms.RandomHorizontalFlip(prob))\n    t_list.append(transforms.ToTensor())\n    if aug_cfg is not None and \"normalization\" in aug_cfg:\n        mean = aug_cfg.normalization.mean\n        std = aug_cfg.normalization.std\n        t_list.append(transforms.Normalize(mean=mean, std=std))\n    return transforms.Compose(t_list)\n\n\ndef get_dataloaders(cfg: DictConfig) -\u003e Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return train/val/test loaders according to *cfg.dataset* settings.\"\"\"\n    data_root = Path(cfg.dataset.get(\"data_dir\", CACHE_DIR))\n    data_root.mkdir(parents=True, exist_ok=True)\n\n    train_transform = _build_transforms(cfg.dataset.get(\"augmentation\", None), is_train=True)\n    test_transform = _build_transforms(cfg.dataset.get(\"augmentation\", None), is_train=False)\n\n    if cfg.dataset.name.lower() in (\"cifar-10\", \"cifar10\"):\n        train_full = datasets.CIFAR10(root=data_root, train=True, download=True, transform=train_transform)\n        test_set = datasets.CIFAR10(root=data_root, train=False, download=True, transform=test_transform)\n    else:\n        raise ValueError(f\"Unsupported dataset {cfg.dataset.name}\")\n\n    train_ratio, val_ratio = cfg.dataset.train_val_split\n    total_train = len(train_full)\n    train_len = int(total_train * train_ratio)\n    val_len = total_train - train_len\n    train_set, val_set = random_split(train_full, [train_len, val_len], generator=torch.Generator().manual_seed(cfg.get(\"seed\", 42)))\n\n    train_loader = DataLoader(\n        train_set,\n        batch_size=int(cfg.training.batch_size),\n        shuffle=True,\n        num_workers=int(cfg.training.num_workers),\n        pin_memory=True,\n    )\n    val_loader = DataLoader(\n        val_set,\n        batch_size=int(cfg.training.batch_size),\n        shuffle=False,\n        num_workers=int(cfg.training.num_workers),\n        pin_memory=True,\n    )\n    test_loader = DataLoader(\n        test_set,\n        batch_size=int(cfg.training.batch_size),\n        shuffle=False,\n        num_workers=int(cfg.training.num_workers),\n        pin_memory=True,\n    )\n\n    return train_loader, val_loader, test_loader\n", "pyproject_toml": "[project]\nname = \"boil-uc-experiments\"\nversion = \"0.1.0\"\ndescription = \"Experiments for BOIL and BOIL-UC on CIFAR-10 using Hydra configuration\"\n\n[project.dependencies]\ntorch = \"^2.0\"\ntorchvision = \"^0.15\"\nhydra-core = \"^1.3.2\"\nomegaconf = \"^2.3\"\nwandb = \"^0.15\"\noptuna = \"^3.5\"\nscikit-learn = \"^1.2\"\nscipy = \"^1.10\"\nnumpy = \"^1.23\"\npandas = \"^2.0\"\nmatplotlib = \"^3.7\"\nseaborn = \"^0.12\"\nscikit-image = \"^0.20\"\ntqdm = \"^4.65\"\n", "train_py": "import os\nimport sys\nimport time\nimport json\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom typing import Dict, Any, List\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig, OmegaConf\nimport hydra\nimport wandb\nimport optuna\nfrom tqdm import tqdm\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import Matern, WhiteKernel, ConstantKernel\nfrom sklearn.linear_model import LinearRegression, BayesianRidge\nfrom scipy.stats import norm\n\nfrom src.preprocess import get_dataloaders\nfrom src.model import build_model\n\n# --------------------------------------------------------------------------------------\n# Helper utilities\n# --------------------------------------------------------------------------------------\n\ndef seed_everything(seed: int = 42) -\u003e None:\n    import random\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef _log_step(wandb_run: \"wandb.sdk.wandb_run.Run\" | None, payload: Dict[str, Any], step: int) -\u003e None:\n    if wandb_run is not None:\n        wandb_run.log(payload, step=step)\n\n\n# --------------------------------------------------------------------------------------\n# Single training execution (model fit for one hyper-parameter setting)\n# --------------------------------------------------------------------------------------\n\ndef _train_once(cfg: DictConfig, wandb_run: \"wandb.sdk.wandb_run.Run | None\", global_step_offset: int = 0) -\u003e Dict[str, Any]:\n    \"\"\"Complete supervised training according to *cfg*. The caller is responsible for\n    passing a *new copy* of the configuration for every different hyper-parameter set so\n    that model, optimiser etc. are rebuilt from scratch.\n\n    Returns a dict with keys: val_acc, val_loss, training_time, confusion_matrix\n    \"\"\"\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    seed_everything(cfg.get(\"seed\", 42))\n\n    train_loader, val_loader, _ = get_dataloaders(cfg)\n\n    model = build_model(cfg)\n    model.to(device)\n\n    # -------------------- optimiser \u0026 scheduler --------------------\n    if cfg.training.optimizer.lower() == \"sgd\":\n        optimizer = torch.optim.SGD(\n            model.parameters(),\n            lr=float(cfg.training.learning_rate),\n            momentum=float(cfg.training.momentum),\n            weight_decay=float(cfg.training.weight_decay),\n        )\n    elif cfg.training.optimizer.lower() == \"adam\":\n        optimizer = torch.optim.Adam(\n            model.parameters(), lr=float(cfg.training.learning_rate), weight_decay=float(cfg.training.weight_decay)\n        )\n    else:\n        raise ValueError(f\"Unsupported optimizer {cfg.training.optimizer}\")\n\n    if str(cfg.training.scheduler).lower() == \"cosine\":\n        scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=int(cfg.training.epochs))\n    else:\n        scheduler = None\n\n    criterion = nn.CrossEntropyLoss()\n\n    best_val_acc = 0.0\n    best_cm: List[List[int]] | None = None\n    start_time = time.time()\n\n    for epoch in range(int(cfg.training.epochs)):\n        model.train()\n        running_loss = 0.0\n        running_correct = 0\n        running_total = 0\n\n        for batch_idx, (images, labels) in enumerate(train_loader):\n            images, labels = images.to(device), labels.to(device)\n            optimizer.zero_grad()\n            logits = model(images)\n            loss = criterion(logits, labels)\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item() * images.size(0)\n            preds = torch.argmax(logits, dim=1)\n            running_correct += (preds == labels).sum().item()\n            running_total += labels.size(0)\n\n            _log_step(\n                wandb_run,\n                {\n                    \"batch_train_loss\": loss.item(),\n                    \"lr\": optimizer.param_groups[0][\"lr\"],\n                },\n                step=global_step_offset + epoch * len(train_loader) + batch_idx,\n            )\n\n            if cfg.trial_mode and batch_idx \u003e= 1:\n                break  # at most two batches in trial mode\n\n        train_loss_epoch = running_loss / max(1, running_total)\n        train_acc_epoch = running_correct / max(1, running_total)\n\n        # -------------------- validation --------------------\n        model.eval()\n        val_losses: List[float] = []\n        val_preds: List[int] = []\n        val_targets: List[int] = []\n        with torch.no_grad():\n            for images, labels in val_loader:\n                images, labels = images.to(device), labels.to(device)\n                logits = model(images)\n                loss = criterion(logits, labels)\n                val_losses.append(loss.item())\n                preds = torch.argmax(logits, dim=1)\n                val_preds.extend(preds.cpu().numpy())\n                val_targets.extend(labels.cpu().numpy())\n\n        val_loss_epoch = float(np.mean(val_losses))\n        val_acc_epoch = float(accuracy_score(val_targets, val_preds))\n        cm = confusion_matrix(val_targets, val_preds).tolist()\n\n        if val_acc_epoch \u003e best_val_acc:\n            best_val_acc = val_acc_epoch\n            best_cm = cm\n\n        _log_step(\n            wandb_run,\n            {\n                \"epoch\": epoch,\n                \"train_loss\": train_loss_epoch,\n                \"train_acc\": train_acc_epoch,\n                \"val_loss\": val_loss_epoch,\n                \"val_acc\": val_acc_epoch,\n            },\n            step=global_step_offset + epoch,\n        )\n\n        if cfg.trial_mode:\n            break  # single epoch in trial mode\n\n        if scheduler is not None:\n            scheduler.step()\n\n    training_time = time.time() - start_time\n\n    return {\n        \"val_acc\": best_val_acc,\n        \"val_loss\": val_loss_epoch,\n        \"training_time\": training_time,\n        \"confusion_matrix\": best_cm,\n    }\n\n\n# --------------------------------------------------------------------------------------\n# BOIL \u0026 BOIL-UC implementation\n# --------------------------------------------------------------------------------------\n\ndef _encode_candidate(lr: float) -\u003e np.ndarray:\n    \"\"\"Map a learning-rate candidate to the GP feature space (log-10 scale).\"\"\"\n    return np.array([np.log10(lr)], dtype=np.float64)\n\n\ndef _sample_random_lr(low: float = 1e-4, high: float = 5e-1) -\u003e float:\n    return float(10 ** np.random.uniform(np.log10(low), np.log10(high)))\n\n\ndef _expected_improvement(mu: np.ndarray, sigma: np.ndarray, y_best: float, xi: float = 1e-2) -\u003e np.ndarray:\n    \"\"\"Compute EI analytically.\"\"\"\n    sigma = np.maximum(sigma, 1e-9)\n    gamma = (mu - y_best - xi) / sigma\n    return sigma * (gamma * norm.cdf(gamma) + norm.pdf(gamma))\n\n\ndef _init_cost_model(cfg_algorithm) -\u003e Any:\n    if str(cfg_algorithm.name).lower() == \"boil-uc\":\n        return BayesianRidge(alpha_1=cfg_algorithm.get(\"alpha_1\", 1e-6), lambda_1=cfg_algorithm.get(\"lambda_1\", 1e-6))\n    return LinearRegression()\n\n\ndef run_boil(cfg: DictConfig, wandb_run: \"wandb.sdk.wandb_run.Run | None\") -\u003e None:\n    \"\"\"Performs BOIL / BOIL-UC hyper-parameter optimisation. Only the learning-rate is\n    optimised here for brevity \u2013 the mechanism generalises to any numeric features.\n    All metrics are logged to *wandb_run*.\n    \"\"\"\n    algo_cfg = cfg.algorithm\n    bo_iters: int = int(algo_cfg.bo_iterations)\n    init_random: int = int(algo_cfg.get(\"init_random\", 5))\n    random_candidates: int = int(algo_cfg.get(\"random_candidates\", 64))\n    beta: float = float(algo_cfg.get(\"beta_uncert\", 0.0))\n\n    # Surrogate for utility (validation accuracy)\n    kernel = ConstantKernel(1.0, (0.1, 10.0)) * Matern(nu=2.5) + WhiteKernel(noise_level=1e-3)\n    gp = GaussianProcessRegressor(kernel=kernel, normalize_y=True, n_restarts_optimizer=2)\n\n    cost_model = _init_cost_model(algo_cfg)\n\n    X: List[np.ndarray] = []          # feature vectors (log-lr)\n    y_util: List[float] = []          # best validation accuracy\n    y_cost: List[float] = []          # wall-clock training time (seconds)\n\n    global_step_offset = 0  # counts the number of optimisation steps for logging\n\n    for it in range(bo_iters):\n        # --------------------------------------------------\n        # Suggest candidate\n        # --------------------------------------------------\n        if it \u003c init_random or len(X) \u003c 2:  # random exploration\n            cand_lr = _sample_random_lr()\n        else:\n            # Fit surrogate models\n            gp.fit(np.vstack(X), np.array(y_util))\n            cost_model.fit(np.vstack(X), np.array(y_cost))\n\n            # Evaluate acquisition on a random grid\n            cand_lrs = [_sample_random_lr() for _ in range(random_candidates)]\n            acq_values = []\n            for lr in cand_lrs:\n                x_feat = _encode_candidate(lr).reshape(1, -1)\n                mu, std = gp.predict(x_feat, return_std=True)\n                ei_val = _expected_improvement(mu, std, y_best=max(y_util))\n                if ei_val \u003c= 0:\n                    acq_values.append(-np.inf)\n                    continue\n\n                if str(algo_cfg.name).lower() == \"boil-uc\":\n                    c_mean, c_std = cost_model.predict(x_feat, return_std=True)\n                    denom = float(c_mean) + beta * float(c_std) + 1e-6\n                else:\n                    denom = float(cost_model.predict(x_feat)[0]) + 1e-6\n                acq_score = np.log(float(ei_val)) - np.log(denom)\n                acq_values.append(acq_score)\n\n            cand_lr = cand_lrs[int(np.argmax(acq_values))]\n\n        # --------------------------------------------------\n        # Build a *deep copy* of the config with candidate hyper-parameters\n        # --------------------------------------------------\n        cand_cfg = OmegaConf.create(OmegaConf.to_container(cfg, resolve=True))\n        cand_cfg.training.learning_rate = cand_lr\n\n        # --------------------------------------------------\n        # Evaluate: full supervised training according to cand_cfg\n        # --------------------------------------------------\n        res = _train_once(cand_cfg, wandb_run, global_step_offset=global_step_offset)\n\n        # --------------------------------------------------\n        # Update datasets for BO\n        # --------------------------------------------------\n        X.append(_encode_candidate(cand_lr))\n        y_util.append(float(res[\"val_acc\"]))\n        y_cost.append(float(res[\"training_time\"]))\n\n        # --------------------------------------------------\n        # Logging per BO iteration\n        # --------------------------------------------------\n        if wandb_run is not None:\n            wandb_run.log(\n                {\n                    \"bo_iteration\": it,\n                    \"candidate_lr\": cand_lr,\n                    \"iter_val_acc\": res[\"val_acc\"],\n                    \"iter_training_time\": res[\"training_time\"],\n                },\n                step=it,\n            )\n\n        # Offset for batch-level logging of next iteration\n        global_step_offset += int(cand_cfg.training.epochs) * 10000  # large gap to avoid collisions\n\n        if cfg.trial_mode:\n            break  # a single BO iteration in trial mode\n\n    # ------------------------------------------------------\n    # Summaries\n    # ------------------------------------------------------\n    best_idx = int(np.argmax(y_util)) if y_util else -1\n    if wandb_run is not None and best_idx \u003e= 0:\n        wandb_run.summary[\"best_val_acc\"] = y_util[best_idx]\n        wandb_run.summary[\"best_learning_rate\"] = (10 ** X[best_idx][0]) if best_idx \u003e= 0 else None\n        wandb_run.summary[\"best_training_time\"] = y_cost[best_idx]\n\n\n# --------------------------------------------------------------------------------------\n# Entry-point\n# --------------------------------------------------------------------------------------\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg: DictConfig) -\u003e None:\n    # Ensure cache directories ---------------------------------------------------------\n    Path(\".cache/wandb\").mkdir(parents=True, exist_ok=True)\n    os.environ[\"WANDB_CACHE_DIR\"] = str(Path(\".cache/wandb\"))\n\n    # Trial-mode \u2192 disable WandB -------------------------------------------------------\n    if cfg.get(\"trial_mode\", False) or cfg.wandb.mode == \"disabled\":\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n        wandb_run = None\n    else:\n        wandb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            config=OmegaConf.to_container(cfg, resolve=True),\n            resume=\"allow\",\n            dir=str(Path(cfg.results_dir) / cfg.run.run_id),\n        )\n\n    # Algorithm-specific dispatch ------------------------------------------------------\n    algo_name = str(cfg.algorithm.name).lower()\n    if algo_name in (\"boil\", \"boil-uc\"):\n        run_boil(cfg, wandb_run)\n    else:  # plain supervised training without BO\n        res = _train_once(cfg, wandb_run)\n        if wandb_run is not None:\n            wandb_run.summary[\"best_val_acc\"] = res[\"val_acc\"]\n            wandb_run.summary[\"training_time\"] = res[\"training_time\"]\n            wandb_run.summary[\"confusion_matrix\"] = res[\"confusion_matrix\"]\n\n    if wandb_run is not None:\n        print(f\"WandB URL: {wandb_run.url}\")\n        wandb_run.finish()\n\n\nif __name__ == \"__main__\":\n    main()\n"}

Analyze the experiment code thoroughly. Ensure it is complete, executable, and ready for publication-quality research experiments.
Output:
{
    "is_code_ready": false,
    "code_issue": "1. Hydra config structure is inconsistent with the CLI that the paper specifies:\n   • config/config.yaml already defines `run:` as a *dictionary*.  When the user launches\n     `python -m src.main run=<run_id>` Hydra will replace that dictionary with the\n     *string* <run_id>.  As a consequence `cfg.run.run_id` that is accessed in\n     src/main.py and src/train.py raises an AttributeError and the whole pipeline\n     crashes during start-up.\n   • Proper use requires a `defaults:` list that points to a config group\n     `run/<name>.yaml` so that `cfg.run.run_id` always exists.  This group and the\n     defaults entry are missing.\n\n2. src/train.py passes the override `run={cfg.run.run_id}` to the child process.\n   Because of the problem above, once cfg.run has become a string this statement\n   crashes before the training script is even spawned.\n\n3. The data/model cache location does not follow the mandatory `.cache/` root –\n   datasets are stored in `.cache/datasets` and TorchVision downloads go to the\n   default ~/.cache directory.\n\n4. The cost-model hyper-parameters (alpha_1, lambda_1) are defined under the\n   `cost_model` section in the configs but _init_cost_model() looks for them in\n   `cfg.algorithm`, so BayesianRidge is always initialised with the hard-coded\n   defaults instead of the YAML values.\n\nBecause of these issues the code cannot be executed successfully from the CLI\nand therefore is NOT ready for immediate use in research experiments."
}
