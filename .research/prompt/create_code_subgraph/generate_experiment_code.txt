
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/run/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/run/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path}

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true
```
- `run`: Experiment run_id (matching a run_id from config/run/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `trial_mode=true` (optional): Lightweight execution for validation (epochs=1, batches limited to 1-2, disable Optuna n_trials=0, **WandB disabled**)

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * **Log ALL metrics to WandB comprehensively**:
    - Use `wandb.log()` at each training step/batch/epoch with ALL relevant metrics
    - Log as frequently as possible (per-batch or per-epoch) to capture training dynamics
  * **Save final/best metrics to WandB summary**:
    - Use `wandb.summary["key"] = value` for final results
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `{results_dir}/config.yaml`
  * **Retrieve comprehensive experimental data from WandB API** for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        history = run.history()  # pandas DataFrame with ALL time-series metrics (train_loss, val_acc, etc.)
        summary = run.summary._json_dict  # Final/best metrics (best_val_acc, final_test_acc, etc.)
        config = dict(run.config)  # Run configuration (hyperparameters, model settings, etc.)
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export **comprehensive** run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
    - Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Use GLOBALLY UNIQUE image filenames to prevent collisions across different runs and directories**:
      * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
      * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- Pass all Hydra overrides to train.py subprocess (e.g., `wandb.mode=disabled`, `trial_mode=true`)
- In trial_mode, automatically set `wandb.mode=disabled`

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 251021-test
    mode: online  # Automatically set to "disabled" in trial_mode
  ```

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Trial Mode Behavior**: trial_mode=true automatically disables WandB (sets wandb.mode=disabled)
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: 1. File-structure mismatch: the top-level file is named "config_yaml" instead of the required "config/config.yaml"; the JSON keys (evaluate_py, train_py …) do not map to the mandatory on-disk paths (src/evaluate.py, src/train.py, …).  This violates the exact-files-only rule.
2. Critical runtime bug in src/train.py, candidate-selection loop (run_boil):
   ````python
   ei_val = _expected_improvement(...)
   if ei_val <= 0:      # <- ei_val is a NumPy array of shape (1,)
       ...
   ````
   Comparing a NumPy array in an `if` statement raises `ValueError: The truth value of an array is ambiguous`.  This stops training immediately, so the code is not executable.
3. Minor but blocking: _expected_improvement returns a NumPy array, but later `np.log(float(ei_val))` assumes a scalar after the failed `if`.

Because of (1) and (2) the package cannot be executed as-is; it therefore does not satisfy the “complete, production-ready” requirement.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "defaults:\n  - run: default  # overwritten via CLI: run=\u003crun_id\u003e\n\nwandb:\n  entity: gengaru617-personal\n  project: 251021-test\n  mode: online  # switched to \"disabled\" automatically when trial_mode=true\n\ntrial_mode: false  # set true from CLI for quick validation\nresults_dir: ./results\nseed: 42\n", "evaluate_py": "import argparse\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nfrom omegaconf import OmegaConf\nfrom scipy.stats import ttest_ind\n\nplt.rcParams.update({\"pdf.fonttype\": 42, \"ps.fonttype\": 42})\n\n# -----------------------------------------------------------------------------\n# Helper functions\n# -----------------------------------------------------------------------------\n\ndef _save_json(obj: Any, path: Path) -\u003e None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\") as f:\n        json.dump(obj, f, indent=2)\n\n\ndef _learning_curve(df: pd.DataFrame, run_id: str, out_dir: Path) -\u003e Path:\n    plt.figure(figsize=(8, 5))\n    if \"val_acc\" in df.columns:\n        plt.plot(df[\"epoch\"], df[\"val_acc\"], label=\"Val Acc\")\n    if \"train_acc\" in df.columns:\n        plt.plot(df[\"epoch\"], df[\"train_acc\"], label=\"Train Acc\")\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(f\"Learning Curve \u2013 {run_id}\")\n    plt.legend()\n    plt.tight_layout()\n    file_path = out_dir / f\"{run_id}_learning_curve.pdf\"\n    plt.savefig(file_path)\n    plt.close()\n    return file_path\n\n\ndef _confusion_matrix(cm: List[List[int]], run_id: str, out_dir: Path) -\u003e Path:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(np.array(cm), annot=True, fmt=\"d\", cmap=\"Blues\")\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"True\")\n    plt.title(f\"Confusion Matrix \u2013 {run_id}\")\n    plt.tight_layout()\n    file_path = out_dir / f\"{run_id}_confusion_matrix.pdf\"\n    plt.savefig(file_path)\n    plt.close()\n    return file_path\n\n# -----------------------------------------------------------------------------\n# Main\n# -----------------------------------------------------------------------------\n\ndef main() -\u003e None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str)\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON string list of run IDs\")\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir)\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    cfg = OmegaConf.load(results_dir / \"config.yaml\")\n    entity, project = cfg.wandb.entity, cfg.wandb.project\n\n    api = wandb.Api()\n    aggregated: Dict[str, Dict[str, Any]] = {}\n    generated: List[Path] = []\n\n    # --------------------- per-run processing ------------------------------\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        hist_df = run.history(keys=None)  # all metrics\n        summ = run.summary._json_dict\n        conf = dict(run.config)\n\n        run_dir = results_dir / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n\n        metrics_path = run_dir / \"metrics.json\"\n        _save_json(hist_df.to_dict(orient=\"list\"), metrics_path)\n        generated.append(metrics_path)\n\n        lc_path = _learning_curve(hist_df, rid, run_dir)\n        generated.append(lc_path)\n\n        if \"confusion_matrix\" in summ and summ[\"confusion_matrix\"] is not None:\n            cm_path = _confusion_matrix(summ[\"confusion_matrix\"], rid, run_dir)\n            generated.append(cm_path)\n\n        aggregated[rid] = {\n            \"best_val_acc\": summ.get(\"best_val_acc\", np.nan),\n            \"training_time\": summ.get(\"best_training_time\", np.nan),\n            \"method\": conf.get(\"run\", {}).get(\"method\", conf.get(\"method\", \"unknown\")),\n        }\n\n    # --------------------- aggregated analysis -----------------------------\n    cmp_dir = results_dir / \"comparison\"\n    cmp_dir.mkdir(parents=True, exist_ok=True)\n\n    agg_path = cmp_dir / \"aggregated_metrics.json\"\n    _save_json(aggregated, agg_path)\n    generated.append(agg_path)\n\n    df = pd.DataFrame.from_dict(aggregated, orient=\"index\")\n\n    methods = df[\"method\"].unique()\n    baseline_method = next(\n        (m for m in methods if \"baseline\" in str(m).lower() or \"comparative\" in str(m).lower()),\n        None,\n    )\n    improvement = {}\n    if baseline_method is not None:\n        base_vals = df[df[\"method\"] == baseline_method][\"best_val_acc\"].astype(float).values\n        for m in methods:\n            if m == baseline_method:\n                continue\n            oth_vals = df[df[\"method\"] == m][\"best_val_acc\"].astype(float).values\n            if oth_vals.size == 0 or base_vals.size == 0:\n                continue\n            imp = (oth_vals.mean() - base_vals.mean()) / base_vals.mean()\n            stat, p_val = ttest_ind(oth_vals, base_vals, equal_var=False)\n            improvement[m] = {\n                \"improvement_vs_baseline\": imp,\n                \"p_value\": p_val,\n            }\n\n    imp_path = cmp_dir / \"derived_metrics.json\"\n    _save_json(improvement, imp_path)\n    generated.append(imp_path)\n\n    # --------------------- figures ----------------------------------------\n    plt.figure(figsize=(10, 5))\n    sns.barplot(x=df.index, y=\"best_val_acc\", hue=\"method\", data=df)\n    for idx, val in enumerate(df[\"best_val_acc\"]):\n        plt.text(idx, val + 0.001, f\"{val:.3f}\", ha=\"center\", va=\"bottom\", fontsize=8)\n    plt.ylabel(\"Best Val Acc\")\n    plt.title(\"Best Validation Accuracy per Run\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    bar_path = cmp_dir / \"comparison_best_val_acc_bar_chart.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    generated.append(bar_path)\n\n    # Print all generated paths\n    for p in generated:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "import subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg: DictConfig) -\u003e None:\n    # ---------------------------------------------------------------------\n    # Persist full resolved config and ensure results directory exists\n    # ---------------------------------------------------------------------\n    results_dir = Path(cfg.results_dir)\n    results_dir.mkdir(parents=True, exist_ok=True)\n    OmegaConf.save(config=cfg, f=str(results_dir / \"config.yaml\"))\n\n    # ---------------------------------------------------------------------\n    # Build hydra overrides forwarded to the subprocess running src.train\n    # ---------------------------------------------------------------------\n    overrides: List[str] = [\n        f\"run={cfg.run.run_id}\",\n        f\"results_dir={cfg.results_dir}\",\n    ]\n\n    if cfg.get(\"trial_mode\", False):\n        overrides.extend(\n            [\n                \"trial_mode=true\",\n                \"wandb.mode=disabled\",\n                \"run.training.epochs=1\",\n                \"run.optuna.n_trials=0\",\n            ]\n        )\n\n    # sustain hydra output path isolation per run\n    overrides.append(f\"hydra.run.dir={cfg.results_dir}/{cfg.run.run_id}/hydra\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + overrides\n    print(\"Executing:\", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "from omegaconf import DictConfig\nimport torch.nn as nn\nfrom torchvision import models\n\n\ndef build_model(cfg: DictConfig) -\u003e nn.Module:\n    \"\"\"Factory that builds a model according to `cfg.model`.\n\n    Currently supports ResNet-18.  Extend here for new architectures.\n    \"\"\"\n\n    name = str(cfg.model.name).lower()\n    num_classes = int(cfg.dataset.num_classes)\n    pretrained = bool(cfg.model.get(\"pretrained\", False))\n\n    if name in (\"resnet-18\", \"resnet18\"):\n        weights = models.ResNet18_Weights.DEFAULT if pretrained else None\n        model = models.resnet18(weights=weights)\n        model.fc = nn.Linear(model.fc.in_features, num_classes)\n    else:\n        raise ValueError(f\"Unsupported architecture: {cfg.model.name}\")\n    return model\n", "preprocess_py": "\"\"\"Complete data-loading \u0026 preprocessing pipeline.\nAll datasets are *always* stored underneath ./.cache/ to comply with the\nspecification.  Any `dataset.data_dir` entry in the Hydra config is ignored\nunless it already points inside .cache/.\n\"\"\"\n\nimport os\nfrom pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import datasets, transforms\nfrom omegaconf import DictConfig\n\n# -----------------------------------------------------------------------------\n# Global cache directory\n# -----------------------------------------------------------------------------\nCACHE_ROOT = Path(\".cache\")\nDATASETS_ROOT = CACHE_ROOT / \"datasets\"\nDATASETS_ROOT.mkdir(parents=True, exist_ok=True)\n\n# Tell torchvision where to cache model weights as well (for completeness)\nos.environ[\"TORCH_HOME\"] = str(CACHE_ROOT / \"torch\")\n\n# -----------------------------------------------------------------------------\n# Build transforms\n# -----------------------------------------------------------------------------\n\ndef _build_transforms(aug_cfg: DictConfig, is_train: bool):\n    t_list = []\n    if is_train and aug_cfg is not None:\n        if \"random_crop\" in aug_cfg:\n            rc = aug_cfg.random_crop\n            t_list.append(transforms.RandomCrop(rc.size, padding=rc.padding))\n        if \"random_horizontal_flip\" in aug_cfg:\n            prob = float(aug_cfg.random_horizontal_flip)\n            t_list.append(transforms.RandomHorizontalFlip(prob))\n    t_list.append(transforms.ToTensor())\n    if aug_cfg is not None and \"normalization\" in aug_cfg:\n        mean = aug_cfg.normalization.mean\n        std = aug_cfg.normalization.std\n        t_list.append(transforms.Normalize(mean=mean, std=std))\n    return transforms.Compose(t_list)\n\n# -----------------------------------------------------------------------------\n# Public API\n# -----------------------------------------------------------------------------\n\ndef get_dataloaders(cfg: DictConfig) -\u003e Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return (train_loader, val_loader, test_loader).\n\n    The root directory is forced to be inside .cache/datasets/\u003cdataset-name\u003e to\n    guarantee compliance with the caching policy.\n    \"\"\"\n\n    # Enforce cache location regardless of what the user specified\n    user_dir = Path(cfg.dataset.get(\"data_dir\", \"\"))\n    if user_dir and str(user_dir).startswith(str(CACHE_ROOT)):\n        data_root = user_dir\n    else:\n        data_root = DATASETS_ROOT / cfg.dataset.name.lower()\n    data_root.mkdir(parents=True, exist_ok=True)\n\n    train_tf = _build_transforms(cfg.dataset.get(\"augmentation\", None), True)\n    test_tf = _build_transforms(cfg.dataset.get(\"augmentation\", None), False)\n\n    name = str(cfg.dataset.name).lower()\n    if name in (\"cifar-10\", \"cifar10\"):\n        train_full = datasets.CIFAR10(root=data_root, train=True, download=True, transform=train_tf)\n        test_set = datasets.CIFAR10(root=data_root, train=False, download=True, transform=test_tf)\n    else:\n        raise ValueError(f\"Unsupported dataset: {cfg.dataset.name}\")\n\n    train_ratio, val_ratio = cfg.dataset.train_val_split\n    total = len(train_full)\n    len_train = int(total * train_ratio)\n    len_val = total - len_train\n    generator = torch.Generator().manual_seed(int(cfg.get(\"seed\", 42)))\n    train_set, val_set = random_split(train_full, [len_train, len_val], generator=generator)\n\n    train_loader = DataLoader(\n        train_set,\n        batch_size=int(cfg.training.batch_size),\n        shuffle=True,\n        num_workers=int(cfg.training.num_workers),\n        pin_memory=True,\n    )\n    val_loader = DataLoader(\n        val_set,\n        batch_size=int(cfg.training.batch_size),\n        shuffle=False,\n        num_workers=int(cfg.training.num_workers),\n        pin_memory=True,\n    )\n    test_loader = DataLoader(\n        test_set,\n        batch_size=int(cfg.training.batch_size),\n        shuffle=False,\n        num_workers=int(cfg.training.num_workers),\n        pin_memory=True,\n    )\n    return train_loader, val_loader, test_loader\n", "pyproject_toml": "[project]\nname = \"boil-uc-experiments\"\nversion = \"0.1.0\"\ndescription = \"Experiments for BOIL and BOIL-UC on CIFAR-10 with Hydra configuration\"\n\n[project.dependencies]\ntorch = \"^2.0\"\ntorchvision = \"^0.15\"\nhydra-core = \"^1.3.2\"\nomegaconf = \"^2.3\"\nwandb = \"^0.15\"\noptuna = \"^3.5\"\nscikit-learn = \"^1.3\"\nscipy = \"^1.11\"\nnumpy = \"^1.24\"\npandas = \"^2.0\"\nmatplotlib = \"^3.7\"\nseaborn = \"^0.12\"\ntqdm = \"^4.65\"\n", "train_py": "import os\nimport sys\nimport time\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport hydra\nimport wandb\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import Matern, WhiteKernel, ConstantKernel\nfrom sklearn.linear_model import LinearRegression, BayesianRidge\nfrom scipy.stats import norm\nfrom tqdm import tqdm\n\nfrom src.preprocess import get_dataloaders\nfrom src.model import build_model\n\n# -----------------------------------------------------------------------------\n# Global cache settings (everything goes underneath ./.cache/)\n# -----------------------------------------------------------------------------\nCACHE_ROOT = Path(\".cache\")\nCACHE_ROOT.mkdir(parents=True, exist_ok=True)\nos.environ[\"TORCH_HOME\"] = str(CACHE_ROOT / \"torch\")  # torchvision weights / datasets\nos.environ[\"HF_HOME\"] = str(CACHE_ROOT / \"hf\")\nos.environ[\"HF_DATASETS_CACHE\"] = str(CACHE_ROOT / \"hf\" / \"datasets\")\nos.environ[\"HF_DATASETS_OFFLINE\"] = \"0\"\nos.environ[\"WANDB_CACHE_DIR\"] = str(CACHE_ROOT / \"wandb\")\n\n# -----------------------------------------------------------------------------\n# Utility helpers\n# -----------------------------------------------------------------------------\n\ndef seed_everything(seed: int) -\u003e None:\n    import random, torch\n\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef _log_step(wb_run: Optional[\"wandb.sdk.wandb_run.Run\"], payload: Dict[str, Any], step: int) -\u003e None:\n    if wb_run is not None:\n        wb_run.log(payload, step=step)\n\n# -----------------------------------------------------------------------------\n# Single supervised training run (utility evaluation)\n# -----------------------------------------------------------------------------\n\ndef _train_once(run_cfg: DictConfig, wb_run: Optional[\"wandb.sdk.wandb_run.Run\"], global_step_offset: int = 0) -\u003e Dict[str, Any]:\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    seed_everything(int(run_cfg.get(\"seed\", 42)))\n\n    train_loader, val_loader, _ = get_dataloaders(run_cfg)\n    model = build_model(run_cfg)\n    model.to(device)\n\n    # Optimiser ----------------------------------------------------------------\n    opt_name = str(run_cfg.training.optimizer).lower()\n    if opt_name == \"sgd\":\n        optimizer = torch.optim.SGD(\n            model.parameters(),\n            lr=float(run_cfg.training.learning_rate),\n            momentum=float(run_cfg.training.momentum),\n            weight_decay=float(run_cfg.training.weight_decay),\n        )\n    elif opt_name == \"adam\":\n        optimizer = torch.optim.Adam(\n            model.parameters(),\n            lr=float(run_cfg.training.learning_rate),\n            weight_decay=float(run_cfg.training.weight_decay),\n        )\n    else:\n        raise ValueError(f\"Unsupported optimizer: {run_cfg.training.optimizer}\")\n\n    # Scheduler -----------------------------------------------------------------\n    sched_name = str(run_cfg.training.scheduler).lower()\n    if sched_name == \"cosine\":\n        scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=int(run_cfg.training.epochs))\n    else:\n        scheduler = None\n\n    criterion = nn.CrossEntropyLoss()\n\n    best_val_acc = 0.0\n    best_cm = None\n    tic = time.time()\n\n    for epoch in range(int(run_cfg.training.epochs)):\n        # ---------------------------- train loop -----------------------------\n        model.train()\n        running_loss, running_correct, running_total = 0.0, 0, 0\n        for b_idx, (images, labels) in enumerate(train_loader):\n            images, labels = images.to(device), labels.to(device)\n            optimizer.zero_grad()\n            logits = model(images)\n            loss = criterion(logits, labels)\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item() * images.size(0)\n            preds = logits.argmax(dim=1)\n            running_correct += (preds == labels).sum().item()\n            running_total += labels.size(0)\n\n            _log_step(\n                wb_run,\n                {\n                    \"batch_train_loss\": loss.item(),\n                    \"lr\": optimizer.param_groups[0][\"lr\"],\n                },\n                step=global_step_offset + epoch * len(train_loader) + b_idx,\n            )\n\n            # In trial mode we only run 2 batches\n            if run_cfg.get(\"trial_mode\", False) and b_idx \u003e= 1:\n                break\n\n        train_loss_epoch = running_loss / max(1, running_total)\n        train_acc_epoch = running_correct / max(1, running_total)\n\n        # --------------------------- validation -----------------------------\n        model.eval()\n        v_losses, v_preds, v_targets = [], [], []\n        with torch.no_grad():\n            for images, labels in val_loader:\n                images, labels = images.to(device), labels.to(device)\n                logits = model(images)\n                loss = criterion(logits, labels)\n                v_losses.append(loss.item())\n                v_preds.extend(logits.argmax(dim=1).cpu().numpy())\n                v_targets.extend(labels.cpu().numpy())\n\n        val_loss_epoch = float(np.mean(v_losses))\n        val_acc_epoch = float(accuracy_score(v_targets, v_preds))\n        cm_epoch = confusion_matrix(v_targets, v_preds).tolist()\n\n        if val_acc_epoch \u003e best_val_acc:\n            best_val_acc, best_cm = val_acc_epoch, cm_epoch\n\n        _log_step(\n            wb_run,\n            {\n                \"epoch\": epoch,\n                \"train_loss\": train_loss_epoch,\n                \"train_acc\": train_acc_epoch,\n                \"val_loss\": val_loss_epoch,\n                \"val_acc\": val_acc_epoch,\n            },\n            step=global_step_offset + epoch,\n        )\n\n        if run_cfg.get(\"trial_mode\", False):\n            break  # single epoch in trial mode\n        if scheduler is not None:\n            scheduler.step()\n\n    training_time = time.time() - tic\n    return {\n        \"val_acc\": best_val_acc,\n        \"val_loss\": val_loss_epoch,\n        \"training_time\": training_time,\n        \"confusion_matrix\": best_cm,\n    }\n\n# -----------------------------------------------------------------------------\n# BOIL / BOIL-UC implementation (learning-rate optimisation as demonstration)\n# -----------------------------------------------------------------------------\n\ndef _encode_lr(lr: float) -\u003e np.ndarray:\n    return np.array([np.log10(lr)], dtype=np.float64)\n\n\ndef _random_lr(low: float = 1e-4, high: float = 5e-1) -\u003e float:\n    return float(10 ** np.random.uniform(np.log10(low), np.log10(high)))\n\n\ndef _expected_improvement(mu: np.ndarray, sigma: np.ndarray, y_best: float, xi: float = 1e-2) -\u003e np.ndarray:\n    sigma = np.maximum(sigma, 1e-9)\n    gamma = (mu - y_best - xi) / sigma\n    return sigma * (gamma * norm.cdf(gamma) + norm.pdf(gamma))\n\n\ndef _init_cost_model(cost_cfg: DictConfig):\n    ctype = str(cost_cfg.type).lower()\n    if ctype == \"bayesianridge\":\n        return BayesianRidge(alpha_1=float(cost_cfg.alpha_1), lambda_1=float(cost_cfg.lambda_1))\n    elif ctype == \"linearregression\":\n        return LinearRegression()\n    else:\n        raise ValueError(f\"Unsupported cost model: {cost_cfg.type}\")\n\n\ndef run_boil(root_cfg: DictConfig, wb_run: Optional[\"wandb.sdk.wandb_run.Run\"]) -\u003e None:\n    run_cfg = root_cfg.run\n    algo_cfg = run_cfg.algorithm\n    cost_cfg = run_cfg.cost_model\n\n    bo_iters = int(algo_cfg.bo_iterations)\n    init_random = int(algo_cfg.get(\"init_random\", 5))\n    random_candidates = int(algo_cfg.get(\"random_candidates\", 64))\n    beta = float(algo_cfg.get(\"beta_uncert\", 0.0))\n\n    # Surrogate for utility (validation accuracy)\n    kernel = ConstantKernel(1.0, (0.1, 10.0)) * Matern(nu=2.5) + WhiteKernel(noise_level=1e-3)\n    gp = GaussianProcessRegressor(kernel=kernel, normalize_y=True, n_restarts_optimizer=2)\n    cost_model = _init_cost_model(cost_cfg)\n\n    X, y_util, y_cost = [], [], []\n    global_step_offset = 0\n\n    for it in range(bo_iters):\n        # ---------------- candidate suggestion ------------------------------\n        if it \u003c init_random or len(X) \u003c 2:\n            cand_lr = _random_lr()\n        else:\n            gp.fit(np.vstack(X), np.array(y_util))\n            cost_model.fit(np.vstack(X), np.array(y_cost))\n\n            cands = [_random_lr() for _ in range(random_candidates)]\n            acq_scores: List[float] = []\n            for lr in cands:\n                feat = _encode_lr(lr).reshape(1, -1)\n                mu_u, std_u = gp.predict(feat, return_std=True)\n                ei_val = _expected_improvement(mu_u, std_u, y_best=max(y_util))\n                if ei_val \u003c= 0:\n                    acq_scores.append(-np.inf)\n                    continue\n                if str(algo_cfg.name).lower() == \"boil-uc\":\n                    mu_c, std_c = cost_model.predict(feat, return_std=True)\n                    denom = float(mu_c) + beta * float(std_c) + 1e-6\n                else:\n                    denom = float(cost_model.predict(feat)[0]) + 1e-6\n                acq_scores.append(np.log(float(ei_val)) - np.log(denom))\n            cand_lr = cands[int(np.argmax(acq_scores))]\n\n        # ---------------- evaluate candidate --------------------------------\n        cand_cfg = OmegaConf.create(OmegaConf.to_container(run_cfg, resolve=True))\n        cand_cfg.training.learning_rate = cand_lr\n        cand_cfg.trial_mode = root_cfg.trial_mode  # propagate trial flag\n        res = _train_once(cand_cfg, wb_run, global_step_offset)\n\n        # ---------------- update datasets -----------------------------------\n        X.append(_encode_lr(cand_lr))\n        y_util.append(float(res[\"val_acc\"]))\n        y_cost.append(float(res[\"training_time\"]))\n\n        if wb_run is not None:\n            wb_run.log(\n                {\n                    \"bo_iteration\": it,\n                    \"candidate_lr\": cand_lr,\n                    \"iter_val_acc\": res[\"val_acc\"],\n                    \"iter_training_time\": res[\"training_time\"],\n                },\n                step=it,\n            )\n\n        # use a large jump to avoid collision between iterations in wandb plots\n        global_step_offset += int(run_cfg.training.epochs) * 10000\n        if root_cfg.trial_mode:\n            break\n\n    # -------------------- summaries ----------------------------------------\n    if y_util and wb_run is not None:\n        best_idx = int(np.argmax(y_util))\n        wb_run.summary[\"best_val_acc\"] = y_util[best_idx]\n        wb_run.summary[\"best_learning_rate\"] = 10 ** X[best_idx][0]\n        wb_run.summary[\"best_training_time\"] = y_cost[best_idx]\n\n# -----------------------------------------------------------------------------\n# Entry-point\n# -----------------------------------------------------------------------------\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg: DictConfig) -\u003e None:\n    # ---------------------------------------------------------------------\n    # WandB initialisation / trial-mode handling\n    # ---------------------------------------------------------------------\n    if cfg.trial_mode or cfg.wandb.mode == \"disabled\":\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n        wb_run = None\n    else:\n        wb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n            dir=str(Path(cfg.results_dir) / cfg.run.run_id),\n        )\n\n    # ---------------------------------------------------------------------\n    # Algorithm dispatch\n    # ---------------------------------------------------------------------\n    algo_name = str(cfg.run.algorithm.name).lower()\n    if algo_name in (\"boil\", \"boil-uc\"):\n        run_boil(cfg, wb_run)\n    else:\n        run_cfg = deepcopy(cfg.run)\n        run_cfg.trial_mode = cfg.trial_mode\n        res = _train_once(run_cfg, wb_run)\n        if wb_run is not None:\n            wb_run.summary[\"best_val_acc\"] = res[\"val_acc\"]\n            wb_run.summary[\"training_time\"] = res[\"training_time\"]\n            wb_run.summary[\"confusion_matrix\"] = res[\"confusion_matrix\"]\n\n    if wb_run is not None:\n        print(f\"WandB URL: {wb_run.url}\")\n        wb_run.finish()\n\n\nif __name__ == \"__main__\":\n    main()\n"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA A100×8
VRAM：80GB×8
RAM：2048 GB

# Current Research Method
{
    "Open Problems": "In BOIL the trade-off between expected utility (EI) and training cost uses a plain LinearRegression model that outputs only the cost mean.  • Learning curves in practice exhibit highly non-linear, heteroscedastic cost patterns (e.g. GPU time depends on batch-size, network width, data-set size, etc.).  • Ignoring cost uncertainty can mis-rank candidate points and waste optimisation budget.  A minimal change that adds uncertainty estimates to the cost model can address this limitation without touching BOIL’s learning-curve GP or augmentation machinery.",
    "Methods": "We keep BOIL intact but replace its cost proxy with a BayesianRidge regressor and modify the acquisition so that the denominator is the optimistic cost mean augmented by a multiple of its predictive standard deviation.  Concretely:  1. Fit sklearn.linear_model.BayesianRidge on concatenated (x,t) → observed_cost.  2. At a candidate z=[x,t] obtain posterior mean μ_c and std σ_c.  3. New cost-aware acquisition:  A(z)=log(EI(z))−log( μ_c + β·σ_c + ε )  (ε=1e−6).  Setting β∈[0,2] interpolates between risk-neutral (β=0, original BOIL) and risk-averse (β>0).  Motivation: penalise points whose cost is both high and uncertain, leading to more reliable wall-clock savings while changing only 5 lines of code.",
    "Experimental Setup": "Data sets: CIFAR-10 CNN (same as BOIL repo) and CartPole-v0 DQN.  Budget: 50 BO iterations, 5 random seeds.  Methods compared: (i) Original BOIL, (ii) BOIL-UC (β=1).  Metrics:  • Wall-clock minutes until the incumbent reaches 90% of best-known test accuracy / return.  • Area-under-curve of best-so-far metric vs time.  Hardware and other hyper-parameters identical to BOIL paper to ensure fair comparison.",
    "Experimental Code": "# --- only the changed parts ---\nfrom sklearn.linear_model import BayesianRidge\n\nclass BOIL_UC(BOIL):\n    def __init__(self,*args, beta_uncert=1.0, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.beta_uncert = beta_uncert\n        # replace linear cost model\n        self.cost_model = BayesianRidge()\n\n    # override utility-cost computation\n    def utility_cost_evaluation(self, z, acq_func, isDebug=False):\n        def _single(z):\n            util = acq_func.acq_kind(z, gp=self.gp)               # EI part (unchanged)\n            mu_c, std_c = self.cost_model.predict(z.reshape(1,-1), return_std=True)\n            adj_cost = max(0.0, mu_c) + self.beta_uncert*std_c + 1e-6\n            return np.log(util) - np.log(adj_cost)\n        if z.ndim==1:\n            return -_single(z)\n        return -np.asarray([_single(p) for p in z])\n\n    # call after every true evaluation\n    def update_cost_model(self):\n        Z = np.hstack((self.X, self.T))\n        self.cost_model.fit(Z, self.Y_cost)\n\n    # ensure model update before acquisition optimisation\n    def suggest_nextpoint(self):\n        self.update_cost_model()\n        return super().suggest_nextpoint()\n",
    "Expected Result": "Across both benchmarks BOIL-UC should reach the target performance about 10-20 % faster in wall-clock time.  The AUC metric is expected to be higher (lower is better) for BOIL-UC in ≥4 of 5 seeds, indicating more consistent cost-aware choices.  When β is set to 0 we exactly reproduce original BOIL numbers, confirming minimal overhead.",
    "Expected Conclusion": "Adding a Bayesian cost model with uncertainty weighting is a tiny change (replace LinearRegression, adjust 5 code lines) yet yields tangible speed-ups and stabler optimisation.  The improvement arises because the acquisition now avoids hyper-parameters whose training cost is both high and uncertain, focusing exploration on cheaper, safer regions.  This demonstrates that even in sophisticated BO frameworks, incorporating predictive uncertainty on auxiliary objectives can provide outsized practical gains with negligible implementation effort."
}

# Experimental Design
- Summary: We compare the original BOIL (Bayesian Optimisation for Learning-curves) against BOIL-UC, our drop-in replacement that equips BOIL with a BayesianRidge cost model and an uncertainty-aware acquisition denominator.  Both algorithms optimise hyper-parameters for training a fixed ResNet-18 on CIFAR-10.  In each BO iteration the candidate (network width, batch-size, learning-rate, etc.) is selected, its single training run is launched, resulting learning-curve observations update BOIL’s GP (utility) and the BayesianRidge (cost).  The acquisition used by BOIL-UC is A(z)=log(EI(z))−log(μ_c+β·σ_c+1e-6).  Experiments run for 50 BO iterations under five random seeds on one A100 GPU.  Wall-clock time until the best validation accuracy reaches 90 % of the global optimum and the time-AUC of best-so-far accuracy are recorded.  The whole workflow is automated via the existing BOIL code-base; only ~15 lines are added to swap the cost model, compute μ_c,σ_c and update β.  Hyper-parameter β is tuned by grid search and the best value is used for the final comparison.
- Evaluation metrics: ['Time-to-Target (minutes)', 'AUC_BestSoFar']

# Experiment Runs

- Run ID: proposed-ResNet-18-11.7-M--CIFAR-10
  Method: proposed
  Model: ResNet-18 (11.7 M)
  Dataset: CIFAR-10
  Config File: config/run/proposed-ResNet-18-11.7-M--CIFAR-10.yaml
  
  Config Content:
  ```yaml
  run_id: proposed-ResNet-18-11.7-M--CIFAR-10
method: proposed
model:
  name: ResNet-18
  num_layers: 18
  width: 64
  pretrained: false
  num_parameters: 11.7M
dataset:
  name: CIFAR-10
  data_dir: ./data/cifar10
  input_size: 32
  num_classes: 10
  augmentation:
    random_crop:
      size: 32
      padding: 4
    random_horizontal_flip: 0.5
    normalization:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2470, 0.2435, 0.2616]
  train_val_split: [0.9, 0.1]
training:
  optimizer: sgd
  learning_rate: 0.1
  momentum: 0.9
  weight_decay: 5e-4
  scheduler: cosine
  batch_size: 256
  epochs: 200
  num_workers: 8
algorithm:
  name: BOIL-UC
  bo_iterations: 50
  random_seeds: [0, 1, 2, 3, 4]
  beta_uncert: 1.0
  acquisition: "log(EI) - log(mu_c + beta_uncert * sigma_c + 1e-6)"
cost_model:
  type: BayesianRidge
  alpha_1: 1e-6
  lambda_1: 1e-6
optuna:
  n_trials: 30
  direction: minimize
  search_space:
    beta_uncert:
      type: categorical
      choices: [0, 0.5, 1.0, 2.0]
    alpha_1:
      type: loguniform
      low: 1e-7
      high: 1e-5
    lambda_1:
      type: loguniform
      low: 1e-7
      high: 1e-5

  ```
  

- Run ID: comparative-1-ResNet-18-11.7-M--CIFAR-10
  Method: comparative-1
  Model: ResNet-18 (11.7 M)
  Dataset: CIFAR-10
  Config File: config/run/comparative-1-ResNet-18-11.7-M--CIFAR-10.yaml
  
  Config Content:
  ```yaml
  run_id: comparative-1-ResNet-18-11.7-M--CIFAR-10
method: comparative-1
model:
  name: ResNet-18
  num_layers: 18
  width: 64
  pretrained: false
  num_parameters: 11.7M
dataset:
  name: CIFAR-10
  data_dir: ./data/cifar10
  input_size: 32
  num_classes: 10
  augmentation:
    random_crop:
      size: 32
      padding: 4
    random_horizontal_flip: 0.5
    normalization:
      mean: [0.4914, 0.4822, 0.4465]
      std:  [0.2470, 0.2435, 0.2616]
  train_val_split: [0.9, 0.1]
training:
  optimizer: sgd
  learning_rate: 0.1
  momentum: 0.9
  weight_decay: 5e-4
  scheduler: cosine
  batch_size: 256
  epochs: 200
  num_workers: 8
algorithm:
  name: BOIL
  bo_iterations: 50
  random_seeds: [0, 1, 2, 3, 4]
cost_model:
  type: LinearRegression
optuna:
  n_trials: 1
  search_space: {}

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**

- ID: microsoft/resnet-18

- Code: from transformers import AutoImageProcessor, AutoModelForImageClassification
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

image_processor = AutoImageProcessor.from_pretrained("microsoft/resnet-18")
model = AutoModelForImageClassification.from_pretrained("microsoft/resnet-18")

inputs = image_processor(image, return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# model predicts one of the 1000 ImageNet classes
predicted_label = logits.argmax(-1).item()
print(model.config.id2label[predicted_label])



**HuggingFace Datasets:**

- ID: uoft-cs/cifar10




Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "import os\nimport random\nimport sys\nimport time\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nimport hydra\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport wandb\nfrom omegaconf import DictConfig, OmegaConf\nfrom scipy.stats import norm\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import ConstantKernel, Matern, WhiteKernel\nfrom sklearn.linear_model import BayesianRidge, LinearRegression\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom tqdm import tqdm\n\nfrom src.model import build_model\nfrom src.preprocess import get_dataloaders\n\n# -----------------------------------------------------------------------------\n# Global cache & environment variables (forced to ./.cache)\n# -----------------------------------------------------------------------------\nCACHE_ROOT = Path(\".cache\").absolute()\nCACHE_ROOT.mkdir(exist_ok=True)\nos.environ.update(\n    {\n        \"TORCH_HOME\": str(CACHE_ROOT / \"torch\"),\n        \"HF_HOME\": str(CACHE_ROOT / \"hf\"),\n        \"HF_DATASETS_CACHE\": str(CACHE_ROOT / \"hf\" / \"datasets\"),\n        \"WANDB_CACHE_DIR\": str(CACHE_ROOT / \"wandb\"),\n    }\n)\n\n# -----------------------------------------------------------------------------\n# Utility helpers\n# -----------------------------------------------------------------------------\n\ndef seed_everything(seed: int) -> None:\n    \"\"\"Seed all relevant RNGs for full reproducibility.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n\n\ndef _log_step(wb_run: Optional[\"wandb.sdk.wandb_run.Run\"], payload: Dict[str, Any], step: int) -> None:\n    \"\"\"Log a payload dict to WandB if enabled.\"\"\"\n    if wb_run is not None:\n        wb_run.log(payload, step=step)\n\n# -----------------------------------------------------------------------------\n# Single supervised training routine (internal use by BOIL/BOIL-UC and baseline)\n# -----------------------------------------------------------------------------\n\ndef _train_once(run_cfg: DictConfig, wb_run: Optional[\"wandb.sdk.wandb_run.Run\"], global_step_offset: int = 0) -> Dict[str, Any]:\n    \"\"\"Train for `run_cfg.training.epochs` (or 1 epoch in trial mode).\n\n    Returns a dict with keys: val_acc, val_loss, training_time, confusion_matrix\n    \"\"\"\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    seed_everything(int(run_cfg.get(\"seed\", 42)))\n\n    train_loader, val_loader, _ = get_dataloaders(run_cfg)\n\n    model = build_model(run_cfg)\n    model.to(device)\n\n    # ----------------- optimiser -------------------------------------------\n    opt_name = str(run_cfg.training.optimizer).lower()\n    if opt_name == \"sgd\":\n        optimizer = torch.optim.SGD(\n            model.parameters(),\n            lr=float(run_cfg.training.learning_rate),\n            momentum=float(run_cfg.training.momentum),\n            weight_decay=float(run_cfg.training.weight_decay),\n        )\n    elif opt_name == \"adam\":\n        optimizer = torch.optim.Adam(\n            model.parameters(),\n            lr=float(run_cfg.training.learning_rate),\n            weight_decay=float(run_cfg.training.weight_decay),\n        )\n    else:\n        raise ValueError(f\"Unsupported optimizer: {run_cfg.training.optimizer}\")\n\n    # ----------------- LR scheduler ----------------------------------------\n    sched_name = str(run_cfg.training.scheduler).lower()\n    scheduler = None\n    if sched_name == \"cosine\":\n        scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(\n            optimizer, T_max=int(run_cfg.training.epochs)\n        )\n\n    criterion = nn.CrossEntropyLoss()\n    best_val_acc, best_cm = 0.0, None\n    tic = time.time()\n\n    for epoch in range(int(run_cfg.training.epochs)):\n        # ---------------- training loop ------------------------------------\n        model.train()\n        running_loss, running_correct, running_total = 0.0, 0, 0\n        for b_idx, (images, labels) in enumerate(train_loader):\n            images, labels = images.to(device), labels.to(device)\n\n            optimizer.zero_grad()\n            logits = model(images)\n            loss = criterion(logits, labels)\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item() * images.size(0)\n            running_correct += (logits.argmax(dim=1) == labels).sum().item()\n            running_total += labels.size(0)\n\n            _log_step(\n                wb_run,\n                {\n                    \"batch_train_loss\": loss.item(),\n                    \"lr\": optimizer.param_groups[0][\"lr\"],\n                },\n                step=global_step_offset + epoch * len(train_loader) + b_idx,\n            )\n\n            # ---------------- trial-mode early exit ------------------------\n            if run_cfg.get(\"trial_mode\", False) and b_idx >= 1:\n                break\n\n        train_loss_epoch = running_loss / max(1, running_total)\n        train_acc_epoch = running_correct / max(1, running_total)\n\n        # ---------------- validation loop ----------------------------------\n        model.eval()\n        v_losses, v_preds, v_targets = [], [], []\n        with torch.no_grad():\n            for images, labels in val_loader:\n                images, labels = images.to(device), labels.to(device)\n                logits = model(images)\n                loss = criterion(logits, labels)\n\n                v_losses.append(loss.item())\n                v_preds.extend(logits.argmax(dim=1).cpu().numpy())\n                v_targets.extend(labels.cpu().numpy())\n\n        val_loss_epoch = float(np.mean(v_losses))\n        val_acc_epoch = float(accuracy_score(v_targets, v_preds))\n        cm_epoch = confusion_matrix(v_targets, v_preds).tolist()\n\n        if val_acc_epoch > best_val_acc:\n            best_val_acc = val_acc_epoch\n            best_cm = cm_epoch\n\n        _log_step(\n            wb_run,\n            {\n                \"epoch\": epoch,\n                \"train_loss\": train_loss_epoch,\n                \"train_acc\": train_acc_epoch,\n                \"val_loss\": val_loss_epoch,\n                \"val_acc\": val_acc_epoch,\n            },\n            step=global_step_offset + epoch,\n        )\n\n        if run_cfg.get(\"trial_mode\", False):\n            break  # run only 1 epoch in trial mode\n\n        if scheduler is not None:\n            scheduler.step()\n\n    training_time = time.time() - tic\n    return {\n        \"val_acc\": best_val_acc,\n        \"val_loss\": val_loss_epoch,\n        \"training_time\": training_time,\n        \"confusion_matrix\": best_cm,\n    }\n\n# -----------------------------------------------------------------------------\n# BOIL / BOIL-UC implementation (learning-rate optimisation only)\n# -----------------------------------------------------------------------------\n\ndef _encode_lr(lr: float) -> np.ndarray:\n    \"\"\"Log-scale encode the learning rate as 1-D feature vector.\"\"\"\n    return np.array([[np.log10(lr)]], dtype=np.float64)  # shape (1,1)\n\n\ndef _random_lr(low: float = 1e-4, high: float = 5e-1) -> float:\n    \"\"\"Sample a LR uniformly in log-space between `low` and `high`.\"\"\"\n    return float(10 ** np.random.uniform(np.log10(low), np.log10(high)))\n\n\ndef _expected_improvement(mu: float, sigma: float, y_best: float, xi: float = 1e-2) -> float:\n    \"\"\"Compute EI for a normal distribution with mean `mu` and std `sigma`.\"\"\"\n    sigma = max(sigma, 1e-9)\n    gamma = (mu - y_best - xi) / sigma\n    return float(sigma * (gamma * norm.cdf(gamma) + norm.pdf(gamma)))\n\n\ndef _init_cost_model(cost_cfg: DictConfig):\n    ctype = str(cost_cfg.type).lower()\n    if ctype == \"bayesianridge\":\n        return BayesianRidge(\n            alpha_1=float(cost_cfg.alpha_1),\n            lambda_1=float(cost_cfg.lambda_1),\n            compute_score=False,\n        )\n    elif ctype == \"linearregression\":\n        return LinearRegression()\n    else:\n        raise ValueError(f\"Unsupported cost model: {cost_cfg.type}\")\n\n\ndef run_boil(root_cfg: DictConfig, wb_run: Optional[\"wandb.sdk.wandb_run.Run\"]) -> None:\n    \"\"\"Execute BOIL/BOIL-UC according to `root_cfg.run` settings.\"\"\"\n    run_cfg, algo_cfg, cost_cfg = root_cfg.run, root_cfg.run.algorithm, root_cfg.run.cost_model\n\n    bo_iters = int(algo_cfg.bo_iterations)\n    init_random = int(algo_cfg.get(\"init_random\", 5))\n    random_candidates = int(algo_cfg.get(\"random_candidates\", 64))\n    beta_uncert = float(algo_cfg.get(\"beta_uncert\", 0.0))\n\n    # Surrogate for utility (validation accuracy)\n    kernel = ConstantKernel(1.0, (0.1, 10.0)) * Matern(nu=2.5) + WhiteKernel(noise_level=1e-3)\n    gp = GaussianProcessRegressor(kernel=kernel, normalize_y=True, n_restarts_optimizer=2)\n    cost_model = _init_cost_model(cost_cfg)\n\n    X_features, y_util, y_cost = [], [], []  # design matrix & targets\n    global_step_offset = 0\n\n    for it in range(bo_iters):\n        # ---------------- Candidate suggestion ---------------------------------\n        if it < init_random or len(X_features) < 2:\n            cand_lr = _random_lr()\n        else:\n            gp.fit(np.vstack(X_features), np.asarray(y_util))\n            cost_model.fit(np.vstack(X_features), np.asarray(y_cost))\n\n            candidate_lrs = [_random_lr() for _ in range(random_candidates)]\n            acq_scores: List[float] = []\n            for lr in candidate_lrs:\n                feat = _encode_lr(lr)\n                mu_u, std_u = gp.predict(feat, return_std=True)\n                mu_u, std_u = float(mu_u.squeeze()), float(std_u.squeeze())\n                ei_val = _expected_improvement(mu_u, std_u, y_best=max(y_util))\n                if ei_val <= 0:\n                    acq_scores.append(-np.inf)\n                    continue\n\n                if str(algo_cfg.name).lower() == \"boil-uc\":\n                    # Uncertainty-aware denominator\n                    if hasattr(cost_model, \"predict\") and \"return_std\" in cost_model.predict.__code__.co_varnames:\n                        mu_c, std_c = cost_model.predict(feat, return_std=True)\n                        mu_c, std_c = float(mu_c.squeeze()), float(std_c.squeeze())\n                    else:\n                        mu_c, std_c = float(cost_model.predict(feat)[0]), 0.0\n                    denom = mu_c + beta_uncert * std_c + 1e-6\n                else:  # plain BOIL\n                    mu_c = float(cost_model.predict(feat)[0])\n                    denom = mu_c + 1e-6\n\n                acq_scores.append(np.log(ei_val) - np.log(denom))\n\n            cand_lr = candidate_lrs[int(np.argmax(acq_scores))]\n\n        # ---------------- Evaluate candidate -----------------------------------\n        cand_cfg = OmegaConf.create(OmegaConf.to_container(run_cfg, resolve=True))\n        cand_cfg.training.learning_rate = cand_lr\n        cand_cfg.trial_mode = root_cfg.trial_mode  # propagate flag\n        res = _train_once(cand_cfg, wb_run, global_step_offset)\n\n        # ---------------- Update datasets --------------------------------------\n        X_features.append(_encode_lr(cand_lr))\n        y_util.append(float(res[\"val_acc\"]))\n        y_cost.append(float(res[\"training_time\"]))\n\n        if wb_run is not None:\n            wb_run.log(\n                {\n                    \"bo_iteration\": it,\n                    \"candidate_lr\": cand_lr,\n                    \"iter_val_acc\": res[\"val_acc\"],\n                    \"iter_training_time\": res[\"training_time\"],\n                },\n                step=it,\n            )\n\n        # large offset to separate batches between BO iterations in WandB UI\n        global_step_offset += int(run_cfg.training.epochs) * 10_000\n\n        if root_cfg.trial_mode:\n            break  # single iteration in trial mode\n\n    # ---------------- Summaries ------------------------------------------------\n    if wb_run is not None and y_util:\n        best_idx = int(np.argmax(y_util))\n        wb_run.summary[\"best_val_acc\"] = y_util[best_idx]\n        wb_run.summary[\"best_learning_rate\"] = 10 ** X_features[best_idx][0][0]\n        wb_run.summary[\"best_training_time\"] = y_cost[best_idx]\n\n# -----------------------------------------------------------------------------\n# Entry-point (hydra)\n# -----------------------------------------------------------------------------\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg: DictConfig) -> None:\n    # Ensure results directory exists & save full resolved config for reproducibility\n    results_dir = Path(cfg.results_dir).absolute()\n    results_dir.mkdir(parents=True, exist_ok=True)\n    OmegaConf.save(config=cfg, f=str(results_dir / \"config.yaml\"))\n\n    # -------------- WandB initialisation --------------------------------------\n    if cfg.trial_mode or cfg.wandb.mode == \"disabled\":\n        os.environ[\"WANDB_MODE\"] = \"disabled\"\n        wb_run = None\n    else:\n        wb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            resume=\"allow\",\n            config=OmegaConf.to_container(cfg, resolve=True),\n            dir=str(results_dir / cfg.run.run_id),\n        )\n\n    # ---------------- Dispatch algorithm --------------------------------------\n    algo_name = str(cfg.run.algorithm.name).lower()\n    if algo_name in {\"boil\", \"boil-uc\"}:\n        run_boil(cfg, wb_run)\n    else:  # plain single training run (sanity / ablation)\n        run_cfg = deepcopy(cfg.run)\n        run_cfg.trial_mode = cfg.trial_mode\n        res = _train_once(run_cfg, wb_run)\n        if wb_run is not None:\n            wb_run.summary[\"best_val_acc\"] = res[\"val_acc\"]\n            wb_run.summary[\"training_time\"] = res[\"training_time\"]\n            wb_run.summary[\"confusion_matrix\"] = res[\"confusion_matrix\"]\n\n    if wb_run is not None:\n        print(f\"WandB URL: {wb_run.url}\")\n        wb_run.finish()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "evaluate_py": "import argparse\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport wandb\nfrom omegaconf import OmegaConf\nfrom scipy.stats import ttest_ind\n\nplt.rcParams.update({\"pdf.fonttype\": 42, \"ps.fonttype\": 42})\n\n# -----------------------------------------------------------------------------\n# Helper utilities\n# -----------------------------------------------------------------------------\n\ndef _save_json(obj: Any, path: Path) -> None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\") as f:\n        json.dump(obj, f, indent=2)\n\n\ndef _learning_curve(df: pd.DataFrame, run_id: str, out_dir: Path) -> Path:\n    plt.figure(figsize=(8, 5))\n    if \"val_acc\" in df.columns:\n        plt.plot(df[\"epoch\"], df[\"val_acc\"], label=\"Val Acc\")\n    if \"train_acc\" in df.columns:\n        plt.plot(df[\"epoch\"], df[\"train_acc\"], label=\"Train Acc\")\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(f\"Learning Curve – {run_id}\")\n    plt.legend()\n    plt.tight_layout()\n    file_path = out_dir / f\"{run_id}_learning_curve.pdf\"\n    plt.savefig(file_path)\n    plt.close()\n    return file_path\n\n\ndef _confusion_matrix(cm: List[List[int]], run_id: str, out_dir: Path) -> Path:\n    plt.figure(figsize=(6, 5))\n    sns.heatmap(np.array(cm), annot=True, fmt=\"d\", cmap=\"Blues\")\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"True\")\n    plt.title(f\"Confusion Matrix – {run_id}\")\n    plt.tight_layout()\n    file_path = out_dir / f\"{run_id}_confusion_matrix.pdf\"\n    plt.savefig(file_path)\n    plt.close()\n    return file_path\n\n# -----------------------------------------------------------------------------\n# Evaluation script (stand-alone)\n# -----------------------------------------------------------------------------\n\ndef main() -> None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str)\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON string list of run IDs\")\n    args = parser.parse_args()\n\n    results_dir = Path(args.results_dir).absolute()\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    cfg = OmegaConf.load(results_dir / \"config.yaml\")\n    entity, project = cfg.wandb.entity, cfg.wandb.project\n\n    api = wandb.Api()\n    aggregated: Dict[str, Dict[str, Any]] = {}\n    generated_files: List[Path] = []\n\n    # ------------------- per-run processing ----------------------------------\n    for rid in run_ids:\n        run = api.run(f\"{entity}/{project}/{rid}\")\n        hist_df = run.history(keys=None)  # full metric history\n        summary = run.summary._json_dict\n        run_cfg = dict(run.config)\n\n        run_dir = results_dir / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n\n        # Save full history\n        metrics_path = run_dir / \"metrics.json\"\n        _save_json(hist_df.to_dict(orient=\"list\"), metrics_path)\n        generated_files.append(metrics_path)\n\n        # Learning curve figure\n        lc_path = _learning_curve(hist_df, rid, run_dir)\n        generated_files.append(lc_path)\n\n        # Confusion matrix, if present\n        if \"confusion_matrix\" in summary and summary[\"confusion_matrix\"] is not None:\n            cm_path = _confusion_matrix(summary[\"confusion_matrix\"], rid, run_dir)\n            generated_files.append(cm_path)\n\n        aggregated[rid] = {\n            \"best_val_acc\": summary.get(\"best_val_acc\", np.nan),\n            \"training_time\": summary.get(\"best_training_time\", np.nan),\n            \"method\": run_cfg.get(\"run\", {}).get(\"method\", run_cfg.get(\"method\", \"unknown\")),\n        }\n\n    # ------------------- aggregated analysis ---------------------------------\n    cmp_dir = results_dir / \"comparison\"\n    cmp_dir.mkdir(parents=True, exist_ok=True)\n\n    agg_metrics_path = cmp_dir / \"aggregated_metrics.json\"\n    _save_json(aggregated, agg_metrics_path)\n    generated_files.append(agg_metrics_path)\n\n    df = pd.DataFrame.from_dict(aggregated, orient=\"index\")\n\n    # Improvement vs baseline (first alphabetical method containing 'baseline' or 'comparative')\n    methods = df[\"method\"].unique()\n    baseline_method = next((m for m in methods if \"baseline\" in str(m).lower() or \"comparative\" in str(m).lower()), None)\n    improvement = {}\n    if baseline_method is not None:\n        base_vals = df[df[\"method\"] == baseline_method][\"best_val_acc\"].astype(float).values\n        for m in methods:\n            if m == baseline_method:\n                continue\n            oth_vals = df[df[\"method\"] == m][\"best_val_acc\"].astype(float).values\n            if len(base_vals) and len(oth_vals):\n                imp = (oth_vals.mean() - base_vals.mean()) / base_vals.mean()\n                stat, p_val = ttest_ind(oth_vals, base_vals, equal_var=False)\n                improvement[m] = {\"improvement_vs_baseline\": imp, \"p_value\": p_val}\n\n    derived_path = cmp_dir / \"derived_metrics.json\"\n    _save_json(improvement, derived_path)\n    generated_files.append(derived_path)\n\n    # ------------------- figures --------------------------------------------\n    plt.figure(figsize=(10, 5))\n    sns.barplot(x=df.index, y=\"best_val_acc\", hue=\"method\", data=df)\n    for idx, val in enumerate(df[\"best_val_acc\"].astype(float)):\n        plt.text(idx, val + 0.001, f\"{val:.3f}\", ha=\"center\", va=\"bottom\", fontsize=8)\n    plt.ylabel(\"Best Val Accuracy\")\n    plt.title(\"Best Validation Accuracy per Run\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.tight_layout()\n    bar_path = cmp_dir / \"comparison_best_val_acc_bar_chart.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    generated_files.append(bar_path)\n\n    # Print all generated file paths (for GitHub Actions log parsing)\n    for p in generated_files:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "preprocess_py": "\"\"\"Data loading & preprocessing utilities (TorchVision CIFAR-10).\n\nAll datasets and downloaded files are stored strictly under ./.cache/ as per\nspecification.  This module exposes `get_dataloaders(cfg)` which returns\n(train_loader, val_loader, test_loader) according to the split ratios in\n`cfg.dataset.train_val_split`.\n\"\"\"\n\nimport os\nfrom pathlib import Path\nfrom typing import Tuple\n\nimport torch\nfrom omegaconf import DictConfig\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import datasets, transforms\n\nCACHE_ROOT = Path(\".cache\").absolute()\nDATASETS_ROOT = CACHE_ROOT / \"datasets\"\nDATASETS_ROOT.mkdir(parents=True, exist_ok=True)\n\nos.environ[\"TORCH_HOME\"] = str(CACHE_ROOT / \"torch\")\n\n# -----------------------------------------------------------------------------\n# Internal helpers\n# -----------------------------------------------------------------------------\n\ndef _build_transforms(aug_cfg: DictConfig, is_train: bool):\n    t_list = []\n    if is_train and aug_cfg is not None:\n        if \"random_crop\" in aug_cfg:\n            rc = aug_cfg.random_crop\n            t_list.append(transforms.RandomCrop(rc.size, padding=rc.padding))\n        if \"random_horizontal_flip\" in aug_cfg:\n            prob = float(aug_cfg.random_horizontal_flip)\n            t_list.append(transforms.RandomHorizontalFlip(prob))\n    t_list.append(transforms.ToTensor())\n    if aug_cfg is not None and \"normalization\" in aug_cfg:\n        mean, std = aug_cfg.normalization.mean, aug_cfg.normalization.std\n        t_list.append(transforms.Normalize(mean=mean, std=std))\n    return transforms.Compose(t_list)\n\n# -----------------------------------------------------------------------------\n# Public API\n# -----------------------------------------------------------------------------\n\ndef get_dataloaders(cfg: DictConfig) -> Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return train/val/test DataLoader triplet according to the config.\"\"\"\n    dataset_name = str(cfg.dataset.name).lower()\n    if dataset_name not in {\"cifar-10\", \"cifar10\"}:\n        raise ValueError(f\"Unsupported dataset: {cfg.dataset.name}\")\n\n    # Ensure we always download/copy to .cache\n    data_root = DATASETS_ROOT / dataset_name\n    data_root.mkdir(parents=True, exist_ok=True)\n\n    train_tf = _build_transforms(cfg.dataset.get(\"augmentation\", None), True)\n    test_tf = _build_transforms(cfg.dataset.get(\"augmentation\", None), False)\n\n    if dataset_name in {\"cifar-10\", \"cifar10\"}:\n        train_full = datasets.CIFAR10(root=data_root, train=True, download=True, transform=train_tf)\n        test_set = datasets.CIFAR10(root=data_root, train=False, download=True, transform=test_tf)\n\n    train_ratio, val_ratio = cfg.dataset.train_val_split\n    total_len = len(train_full)\n    len_train = int(total_len * train_ratio)\n    len_val = total_len - len_train\n\n    generator = torch.Generator().manual_seed(int(cfg.get(\"seed\", 42)))\n    train_set, val_set = random_split(train_full, [len_train, len_val], generator=generator)\n\n    dl_kwargs = dict(\n        batch_size=int(cfg.training.batch_size),\n        num_workers=int(cfg.training.num_workers),\n        pin_memory=True,\n    )\n    train_loader = DataLoader(train_set, shuffle=True, **dl_kwargs)\n    val_loader = DataLoader(val_set, shuffle=False, **dl_kwargs)\n    test_loader = DataLoader(test_set, shuffle=False, **dl_kwargs)\n    return train_loader, val_loader, test_loader\n",
    "model_py": "\"\"\"Model factory – currently supports ResNet-18 (TorchVision).\n\nCall build_model(cfg) with the *run* sub-config (has .model & .dataset).\n\"\"\"\n\nfrom omegaconf import DictConfig\nimport torch.nn as nn\nfrom torchvision import models\n\n\ndef build_model(cfg: DictConfig) -> nn.Module:\n    name = str(cfg.model.name).lower()\n    num_classes = int(cfg.dataset.num_classes)\n    pretrained = bool(cfg.model.get(\"pretrained\", False))\n\n    if name in {\"resnet-18\", \"resnet18\"}:\n        weights = models.ResNet18_Weights.DEFAULT if pretrained else None\n        model = models.resnet18(weights=weights)\n        model.fc = nn.Linear(model.fc.in_features, num_classes)\n    else:\n        raise ValueError(f\"Unsupported architecture: {cfg.model.name}\")\n    return model\n",
    "main_py": "import subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=\"1.3\")\ndef main(cfg: DictConfig) -> None:\n    \"\"\"Main orchestrator: spawns `src.train` as a subprocess for a single run.\"\"\"\n    # ---------------------------------------------------------------------\n    # Persist resolved config in results directory for bookkeeping\n    # ---------------------------------------------------------------------\n    results_dir = Path(cfg.results_dir).absolute()\n    results_dir.mkdir(parents=True, exist_ok=True)\n    OmegaConf.save(config=cfg, f=str(results_dir / \"config.yaml\"))\n\n    # ---------------------------------------------------------------------\n    # Compose Hydra override list to forward to child process (src.train)\n    # ---------------------------------------------------------------------\n    overrides: List[str] = [f\"run={cfg.run.run_id}\", f\"results_dir={cfg.results_dir}\"]\n\n    if cfg.get(\"trial_mode\", False):\n        overrides.extend(\n            [\n                \"trial_mode=true\",\n                \"wandb.mode=disabled\",\n                \"run.training.epochs=1\",\n                \"run.optuna.n_trials=0\",\n            ]\n        )\n\n    # Ensure Hydra output directory inside the dedicated run folder (avoid clutter)\n    overrides.append(f\"hydra.run.dir={cfg.results_dir}/{cfg.run.run_id}/hydra\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\"] + overrides\n    print(\"Executing:\", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject_toml": "[project]\nname = \"boil-uc-experiments\"\nversion = \"0.1.0\"\ndescription = \"Experiments for BOIL & BOIL-UC on CIFAR-10 with Hydra configuration\"\nauthors = [\"AI Researcher <research@ai.example.com>\"]\n\n[project.dependencies]\ntorch = \"^2.0\"\ntorchvision = \"^0.15\"\nhydra-core = \"^1.3.2\"\nomegaconf = \"^2.3\"\nwandb = \"^0.15\"\noptuna = \"^3.5\"\nscikit-learn = \"^1.3\"\nscipy = \"^1.11\"\nnumpy = \"^1.24\"\npandas = \"^2.0\"\nmatplotlib = \"^3.7\"\nseaborn = \"^0.12\"\ntqdm = \"^4.65\"\n",
    "config_yaml": "# =============================================================================\n# Root Hydra configuration – all values can be overridden via CLI or run-files\n# =============================================================================\n\ndefaults:\n  - run: default  # overridden as run=<run_id>\n\n# ---------------- WandB ----------------\nwandb:\n  entity: gengaru617-personal\n  project: 251021-test\n  mode: online  # auto-overridden to \"disabled\" in trial mode\n\n# ---------------- Global settings ----------------\ntrial_mode: false  # set true via CLI for lightweight validation\nresults_dir: ./results\nseed: 42\n"
}
